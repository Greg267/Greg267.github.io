<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" href="https://github.com/Greg267/rss.xml"><link rel="alternate" type="application/atom+xml" href="https://github.com/Greg267/atom.xml"><link rel="alternate" type="application/json" href="https://github.com/Greg267/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><link rel="canonical" href="https://github.com/Greg267/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><title>数据结构 | Greg yang =</title><meta name="generator" content="Hexo 6.2.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">数据结构</h1><div class="meta"><span class="item" title="创建时间：2022-05-12 20:08:09"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2022-05-12T20:08:09+08:00">2022-05-12</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>16k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>15 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Greg yang</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva1.sinaimg.cn/large/008qflI6ly8h25fy4pwdmj30dw0813zq.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/008qflI6ly8h25fuse10xj31900u0go8.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/008qflI6ly8h25g83b2kjj308c05kglo.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/008qflI6ly8h25fuse10xj31900u0go8.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/008qflI6ly8h25g98rrmwj308c04p3yk.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/008qflI6ly8h25g9pl9l2j308c05jaab.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://github.com/Greg267/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Greg yang"><meta itemprop="description" content=", "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content=""></span><div class="body md" itemprop="articleBody"><h2 id="1数据结构绪论"><a class="anchor" href="#1数据结构绪论">#</a> 1. 数据结构绪论</h2><p>数据结构是一门研究非数值计算的程序设计问题中的操作对象，以及它们之间的关系和操作等相关问题的学科</p><h3 id="11基本概念和术语"><a class="anchor" href="#11基本概念和术语">#</a> 1.1. 基本概念和术语</h3><p>数据：是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合</p><p>数据元素：是组成数据的，有一定意义的基本单位，在计算机中通常作为整体处理，也被称为记录。比如在人类中，人就是一个数据元素</p><p>数据项：一个数据元素可以由若干个数据项组成。比如人这样的数据元素，可以有鼻子，眼睛，耳朵等数据项，也可以有姓名，年龄，家庭住址等数据项，具体有哪些数据项，要视你做的系统来决定。数据项是数据不可分割的最小单位，但是在我们真正讨论问题时，要着眼于数据元素，就像我们看电影时，我们一般讨论的是电影角色，而不是角色的眼睛鼻子，耳朵等</p><p>数据对象：是性质相同的数据元素的集合，是数据的子集；性质相同：是指数据元素拥有相同数量和类型的数据项</p><p>数据结构：是相互之间存在一种或多种特定关系的数据元素的集合</p><p><img data-src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BB%AA%E8%AE%BA/%E5%85%B3%E7%B3%BB.png" alt="1"></p><h3 id="12逻辑结构和物理结构"><a class="anchor" href="#12逻辑结构和物理结构">#</a> 1.2. 逻辑结构和物理结构</h3><h4 id="121逻辑结构"><a class="anchor" href="#121逻辑结构">#</a> 1.2.1 逻辑结构</h4><p>是指数据对象中数据元素之间的相互关系</p><p>1. 集合结构：集合结构中的数据元素除了同属于一个集合外，它们之间没有任何其他关系</p><p><img data-src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BB%AA%E8%AE%BA/%E9%9B%86%E5%90%88%E7%BB%93%E6%9E%84.png" alt="1"></p><p>2. 线性结构：线性结构中的数据元素是一对一的关系</p><p><img data-src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BB%AA%E8%AE%BA/%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.png" alt="1"></p><p>3. 树形结构：树形结构中的数据元素之间存在一种一对多的层次关系</p><p><img data-src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BB%AA%E8%AE%BA/%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84.png" alt="1"></p><p>图形结构：图形结构的数据元素是多对多的关系</p><p><img data-src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BB%AA%E8%AE%BA/%E5%9B%BE%E5%BD%A2%E7%BB%93%E6%9E%84.png" alt="1"></p><h4 id="122物理结构"><a class="anchor" href="#122物理结构">#</a> 1.2.2. 物理结构</h4><p>是指数据的逻辑结构在计算机中的存储形式</p><p>1. 顺序存储结构：顺序存储结构是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一样的，有点类似于数组</p><p>2. 链式存储结构：链式存储结构是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。数据元素的存储关系并不能反映其逻辑关系，因此需要用一个指针存放数据元素的地址，这样通过地址就可以找到相关数据元素的位置</p><h3 id="13抽象数据类型"><a class="anchor" href="#13抽象数据类型">#</a> 1.3. 抽象数据类型</h3><h4 id="131数据类型"><a class="anchor" href="#131数据类型">#</a> 1.3.1. 数据类型</h4><p>是指一组性质相同的值的集合以及定义在此集合上的一些操作的总称</p><p>按照取值的不同，数据类型可以分为两类：1. 原子类型：是不可再分解的类型，包括整型，实型，字符型等；2. 结构类型：由若干个类型组合而成，是可以再分解的，例如，整型数组是由若干整型数据</p><h4 id="132抽象数据类型"><a class="anchor" href="#132抽象数据类型">#</a> 1.3.2. 抽象数据类型</h4><p>抽象数据类型：是指一个数字模型以及定义在该模型上的一组操作。抽象数据类型的定义仅取决于它的一组逻辑特性，而与其在计算机内部如何表示和实现无关。</p><p>比如在一些地图软件内会涉及到定位，这时我们就可以定义一个叫 Point 的抽象数据类型，它有 x,y,z 这三个整型变量，这样我们就很方便的操作一个叫 point 数据变量就能知道这一点的坐标了</p><p>抽象数据类型体现了程序设计中问题分解，抽象和信息隐藏的特性</p><h2 id="2算法"><a class="anchor" href="#2算法">#</a> 2. 算法</h2><p>算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作</p><p>算法的五个基本特性：输入，输出，有穷性，确定性和可行性</p><p>有穷性：指算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每一个步骤在可接受的时间内完成</p><p>确定性：算法的每一步骤都具有确定的含义，不会出现二义性。</p><h3 id="21算法设计的要求"><a class="anchor" href="#21算法设计的要求">#</a> 2.1. 算法设计的要求</h3><p>正确性：算法的正确性是指算法至少应该具有输入，输出和加工处理无歧义性，能正确反映问题的需求，能够得到问题的正确答案</p><p>可读性：算法设计的另一目的是为了便于阅读，理解和交流</p><p>健壮性：当输入数据不合理时，算法也能做出相关处理，而不是产生异常或莫名其妙的结果</p><p>时间效率高和存储量低</p><h3 id="22函数的渐近增长"><a class="anchor" href="#22函数的渐近增长">#</a> 2.2. 函数的渐近增长</h3><p>输入规模 n 在没有限制的情况下，只要超过一个数值 N，这个函数就总是大于另一个函数，我们称函数是渐近增长的</p><p>与最高次项相乘的常数并不重要</p><p>最高次项的指数大的，函数随着 n 的增长，结果也会变得增长特别快</p><p>判断一个算法的效率时，函数中的常数和其他次要项可以忽略，而更应该关注主项 (最高阶项) 的阶数</p><h3 id="22算法时间复杂度"><a class="anchor" href="#22算法时间复杂度">#</a> 2.2. 算法时间复杂度</h3><p><img data-src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%AE%9A%E4%B9%89.png" alt="1"></p><h4 id="221推导大o阶"><a class="anchor" href="#221推导大o阶">#</a> 2.2.1. 推导大 O 阶</h4><p><img data-src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/%E6%8E%A8%E5%AF%BC%E5%A4%A7O%E9%98%B6.png" alt="1"></p><h4 id="222常数阶"><a class="anchor" href="#222常数阶">#</a> 2.2.2. 常数阶</h4><p><img data-src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/%E9%AB%98%E6%96%AF%E7%AE%97%E6%B3%95.png" alt="1"></p><p>这个算法的运行次数函数是 f (n)=3，根据我们推导大 O 阶的方法，第一步就是把常数项 3 改为 1，在保留最高阶项时发现，它根本没有最高阶项，所以这个算法的时间复杂度为 O [1]，另外，我们试想一下，如果这个算法中的语句 sum=(1+n)*n/2 有 10 句，事实上无论 n 为多少，上面的两段代码就是 3 次和 12 次执行的差异，这种与问题的大小无关 (n 的多少)，执行时间恒定的算法，我们称之为具有 O [1] 的时间复杂度，又叫常数阶。注意：不管这个常数是多少，我们都记作 O [1]，而不能是 O [3]，等其他任何数字</p><h4 id="223线性阶"><a class="anchor" href="#223线性阶">#</a> 2.2.3. 线性阶</h4><p>要分析算法的复杂度，关键就是要分析循环结构的运行情况，循环 n 次，它的循环复杂度就为 O [n]</p><h4 id="224对数阶"><a class="anchor" href="#224对数阶">#</a> 2.2.4. 对数阶</h4><p><img data-src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/%E5%AF%B9%E6%95%B0%E9%98%B6.png" alt="1"></p><p>退出循环的条件为又多少个 2 相乘后大于 n，即 2^x=n; 即 x=log2n, 所以这个循环的时间复杂度为 O [logn]</p><h4 id="225平方阶"><a class="anchor" href="#225平方阶">#</a> 2.2.5. 平方阶</h4><p>循环里面嵌套循环，此时的时间复杂度就是平方阶的，比如内循环 m 次，外循环 n 次，时间复杂度就为 O [nxm]，所以我们可以总结得出，循环的时间复杂度等于循环体的复杂度乘以该循环运行的次数</p><h3 id="23常见的时间复杂度"><a class="anchor" href="#23常见的时间复杂度">#</a> 2.3. 常见的时间复杂度</h3><p><img data-src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/%E5%B8%B8%E8%A7%81%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6.png" alt="1"></p><p>不同时间复杂度耗时从小到大依次是</p><p><img data-src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/%E4%B8%8D%E5%90%8C%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%80%97%E6%97%B6.png" alt="1"></p><h3 id="24最坏情况与平均情况"><a class="anchor" href="#24最坏情况与平均情况">#</a> 2.4. 最坏情况与平均情况</h3><p>最坏情况运行时间是一种保证，那就是运行时间将不会再坏了，通常情况下，我们提到的运行时间都是最坏情况的运行时间。平均运行时间是所有情况中最有意义的，因为它是期望的运行时间，一般在没有特殊说明的情况下，都是指最坏时间复杂度。</p><h3 id="25算法空间复杂度"><a class="anchor" href="#25算法空间复杂度">#</a> 2.5. 算法空间复杂度</h3><p><img data-src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6.png" alt="1"></p><h2 id="3线性表"><a class="anchor" href="#3线性表">#</a> 3. 线性表</h2><p>线性表 (List)：零个或多个数据元素的有限序列。注意：有限</p><p>一个元素前面紧挨着的元素称为直接前驱元素，后面紧接着的元素称为直接后继元素。</p><p>线性表元素的个数 n (n&gt;0) 定义为线性表的长度，当 n=0 时，称为空表。元素在线性表中的位置称为元素在线性表中的位序</p><p>在复杂的线性表中，一个数据元素可以由若干个数据项组成</p><h3 id="31线性表的抽象数据类型"><a class="anchor" href="#31线性表的抽象数据类型">#</a> 3.1. 线性表的抽象数据类型</h3><p>就是对线性表的操作，就是增 删 查 改</p><h3 id="32线性表的顺序存储结构"><a class="anchor" href="#32线性表的顺序存储结构">#</a> 3.2. 线性表的顺序存储结构</h3><h4 id="321顺序存储定义"><a class="anchor" href="#321顺序存储定义">#</a> 3.2.1. 顺序存储定义</h4><p>线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素</p><h4 id="322顺序存储方式"><a class="anchor" href="#322顺序存储方式">#</a> 3.2.2. 顺序存储方式</h4><p>就是用一维数组来实现顺序存储结构，描述顺序存储结构需要三个属性：1. 存储空间的起始位置，数组，它的存储位置就是存储空间的存储位置；2. 线性表的最大存储容量，数组长度；3. 线性表的当前长度；</p><h4 id="323地址计算方法"><a class="anchor" href="#323地址计算方法">#</a> 3.2.3. 地址计算方法</h4><p>存储器中的每个存储单元都有自己的编号，这个编号称为地址。当一个位置确定后，后面的位置都是可以计算的，只需要知道存储的数据占有多少个存储单元就可以</p><h3 id="33顺序存储结构的插入和删除"><a class="anchor" href="#33顺序存储结构的插入和删除">#</a> 3.3. 顺序存储结构的插入和删除</h3><h4 id="331插入操作"><a class="anchor" href="#331插入操作">#</a> 3.3.1. 插入操作</h4><p>思路：先看插入位置合理与否，如果不合理，抛出异常；然后，判断线性表长度与数组长度，如果前者大于后者，则抛出异常或者动态增加容量；然后从最后一个元素开始向前遍历到第 i 个位置，分别将它们都向后移动一个位置；然后将要插入元素填入位置 i 处；最后表长增加 1.</p><h4 id="332删除操作"><a class="anchor" href="#332删除操作">#</a> 3.3.2. 删除操作</h4><p>思路：先看如果删除位置不合理，抛出异常；然后，取出删除元素；然后，从删除元素位置开始遍历到最后一个元素位置，分别将它们都向前移动一个位置；最后，表长减 1；</p><h4 id="333线性表顺序存储结构的优缺点"><a class="anchor" href="#333线性表顺序存储结构的优缺点">#</a> 3.3.3. 线性表顺序存储结构的优缺点</h4><p><img data-src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%80%A7%E8%A1%A8/%E7%BA%BF%E6%80%A7%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9.png" alt="1"></p><h3 id="34线性表的链式存储结构"><a class="anchor" href="#34线性表的链式存储结构">#</a> 3.4. 线性表的链式存储结构</h3><p>线性表的链式存储结构的特点是用一组任意的存储单元存储线性表的数据元素，这组元素可以是连续的，也可以是不连续的</p><h4 id="341线性表链式存储结构定义"><a class="anchor" href="#341线性表链式存储结构定义">#</a> 3.4.1. 线性表链式存储结构定义</h4><p>我们把存储数据元素信息的域称为数据域，把存储直接后继位置的域称为指针域，指针域中存储的信息称做指针或链，这两部分信息组成数据 ai 的存储映像，称为结点，就是 c 语言里面的链表</p><p>我们把链表中第一个结点的存储位置叫做头指针，线性链表的最后一个结点指针为空，通常用 NULL 表示</p><p>有时我们为了更加方便的对链表进行操作，会在单链表的第一个结点前附设一个结点，称为头结点，头结点的数据与可以不存储任何信息，也可以存储如线性表的长度等信息，没什么特别的作用，这个头结点的指针域存放的就是头指针</p><p><img data-src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%80%A7%E8%A1%A8/%E5%A4%B4%E7%BB%93%E7%82%B9%E4%B8%8E%E5%A4%B4%E6%8C%87%E9%92%88.png" alt="1"></p><p>用图像表示单链表</p><p><img data-src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%80%A7%E8%A1%A8/%E7%94%A8%E5%9B%BE%E5%83%8F%E8%A1%A8%E7%A4%BA%E5%8D%95%E9%93%BE%E8%A1%A8.png" alt="1"></p><h3 id="35单链表的读取"><a class="anchor" href="#35单链表的读取">#</a> 3.5. 单链表的读取</h3><p>步骤：1. 声明一个结点。2. 遍历链表，p=p-&gt;next，直到 p 为 NULL</p><h3 id="36单链表的插入与删除"><a class="anchor" href="#36单链表的插入与删除">#</a> 3.6. 单链表的插入与删除</h3><h4 id="361单链表的插入"><a class="anchor" href="#361单链表的插入">#</a> 3.6.1. 单链表的插入</h4><p>关键是插入的那个结点和前后两个结点的关系：比如说要在 p q 中插入一个 s ，则需要找到 p，然后将 s-&gt;next=p-&gt;next,p-&gt;next=s; 而且这两个的顺序不能交换</p><p><img data-src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%80%A7%E8%A1%A8/%E7%BB%93%E7%82%B9%E6%8F%92%E5%85%A5.png" alt="1"></p><h4 id="362单链表的删除"><a class="anchor" href="#362单链表的删除">#</a> 3.6.2. 单链表的删除</h4><p>关键在于绕过被删除的那个结点，比如说要删除 p q 中间的 s 则 s=p-&gt;next,p-&gt;next=s-&gt;next</p><p><img data-src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%80%A7%E8%A1%A8/%E7%BB%93%E7%82%B9%E5%88%A0%E9%99%A4.png" alt="1"></p><h3 id="37单链表的整表创建"><a class="anchor" href="#37单链表的整表创建">#</a> 3.7. 单链表的整表创建</h3><p>头插法，将新结点插入在头结点与新一结点之间；</p><p><img data-src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%80%A7%E8%A1%A8/%E9%93%BE%E8%A1%A8%E5%88%9B%E5%BB%BA.png" alt="1"></p><p>尾插法：创建一个结点使它一直指向最后一个结点，具体做法为，将新结点放在尾结点的后面，然后将新结点赋给尾结点，此时新结点就为尾结点，然后再将为结点的 next 改为 NULL</p><p><img data-src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%80%A7%E8%A1%A8/%E9%93%BE%E8%A1%A8%E5%88%9B%E5%BB%BA%E5%B0%BE.png" alt="1"></p><h3 id="38单链表的整表删除"><a class="anchor" href="#38单链表的整表删除">#</a> 3.8. 单链表的整表删除</h3><p>做法是创建两个结点 p q，先将 p 的 next 给 q，然后释放 p，再然后将 q 赋给 p，重复执行，就可以了</p><p><img data-src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%80%A7%E8%A1%A8/%E9%93%BE%E8%A1%A8%E6%95%B4%E4%BD%93%E5%88%A0%E9%99%A4.png" alt="1"></p><h3 id="39单链表结构和顺序存储结构的优缺点"><a class="anchor" href="#39单链表结构和顺序存储结构的优缺点">#</a> 3.9. 单链表结构和顺序存储结构的优缺点</h3><p>若线性表需要频繁查找，很少进行插入和删除操作时，宜用顺序存储结构，若需要频繁插入和删除时，宜用单链表结构</p><h3 id="310静态链表"><a class="anchor" href="#310静态链表">#</a> 3.10. 静态链表</h3><p>让数组的元素都由两个数据域组成，data 和 cur，数据域 data 用来存放数据元素，也就是通常要处理的元素，而 cur 就相当于链表里的 next，用来存放该元素的后继在数组中的下标，我们把这种用数组描述的链表叫做静态链表</p><p>我们通常把未被使用的数组元素称为备用链表；数组的第一个元素的 cur 存放备用链表的第一个结点的下标；数组的最后一个元素的 cur 则存放第一个有数值的元素的下标，相当于单链表中的头结点作用</p><h4 id="3101静态链表的插入操作"><a class="anchor" href="#3101静态链表的插入操作">#</a> 3.10.1. 静态链表的插入操作</h4><p>首先要获取备用链表的第一个结点，即数组的 0，然后将这个结点的后一个结点拿来做备用；然后，我们采取的是不移动结点本来的位置，而是改变结点里面的下标，使之在要插入的位置中间；先找到要插入的位置 i 之前的位置，然后把第 i 个元素之前的 cur 赋值给新元素的 cur，再把新元素的下标赋给赋值给第 i 个元素之前元素的 cur</p><p><img data-src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%80%A7%E8%A1%A8/%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A51.png" alt="1"></p><p><img data-src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%80%A7%E8%A1%A8/%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8%E6%8F%92%E5%85%A52.png" alt="1"></p><p><img data-src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%80%A7%E8%A1%A8/%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8%E6%8F%92%E5%85%A53.png" alt="1"></p><h4 id="3102静态链表的删除"><a class="anchor" href="#3102静态链表的删除">#</a> 3.10.2. 静态链表的删除</h4><p>如果删除的是第一个结点，那么，首先要把尾结点的 cur 拿到，然后将尾结点的 cur 改成尾结点 cur 的 cur，然后将删除的那个结点释放，就是把 0 的 cur 给删除的那个结点的 cur，然后再把要删除的那个结点的下标给 0 的 cur</p><p><img data-src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%80%A7%E8%A1%A8/%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8%E5%88%A0%E9%99%A41.png" alt="1"></p><p><img data-src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%80%A7%E8%A1%A8/%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8%E9%87%8A%E6%94%BE.png" alt=""></p><h4 id="3103静态链表优缺点"><a class="anchor" href="#3103静态链表优缺点">#</a> 3.10.3. 静态链表优缺点</h4><p><img data-src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%80%A7%E8%A1%A8/%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9.png" alt="1"></p><h3 id="311循环链表"><a class="anchor" href="#311循环链表">#</a> 3.11. 循环链表</h3><p>将单链表中终端结点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表就称为单循环链表，简称循环链表</p><p>为了使空链表与非空链表处理一致，我们通常设一个头结点</p><p><img data-src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%80%A7%E8%A1%A8/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E5%A4%B4%E7%BB%93%E7%82%B9.png" alt="1"></p><p>此时的判断循环的条件也有差异，单链表的判断条件为 p-&gt;next 不为空，而循环链表的条件为 p-&gt;next 不为头结点</p><p>当然，此时如果要访问最后一个结点，所需时间复杂度仍为 O [n]，但我们可以改造一下这个循环链表，不用头指针，而是用指向终端结点的尾指针来表示循环链表</p><p><img data-src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%80%A7%E8%A1%A8/%E6%94%B9%E9%80%A0%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8.png" alt="1"></p><h3 id="312双向链表"><a class="anchor" href="#312双向链表">#</a> 3.12. 双向链表</h3><p>双向链表是在单链表的每个结点中，在设置一个指向其前驱结点的指针域</p><p><img data-src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%80%A7%E8%A1%A8/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E6%8F%92%E5%85%A5.png" alt="1"></p><p><img data-src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%80%A7%E8%A1%A8/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E5%88%A0%E9%99%A4.png" alt="1"></p><h2 id="4栈与队列"><a class="anchor" href="#4栈与队列">#</a> 4. 栈与队列</h2><h3 id="41栈"><a class="anchor" href="#41栈">#</a> 4.1. 栈</h3><p>栈在软件应用中非常普遍，例如网页后退，撤销操作等，栈是限定仅在表尾进行插入和删除操作的线性表，我们把允许插入和删除的一端称为栈顶，另一端称为栈底，不含任何元素的栈称为空栈，栈又称为先进后出的线性表</p><p>栈的插入操作，叫做进栈，也称压栈，入栈；栈的删除操作，叫作出栈，也有的叫作弹栈</p><h4 id="411进出栈变化形式"><a class="anchor" href="#411进出栈变化形式">#</a> 4.1.1. 进出栈变化形式</h4><p>栈只对线性表插入和删除的位置有限制而已，并没有对元素进出的时间有限制，也就是说，在不是所有元素都进栈的情况下，先进栈的元素也可以先出来，比如 3 个整型数字 1 2 3 依次进栈，可以按如下方式次序 1 进 2 进 2 出 1 出 3 进 3 出</p><h3 id="42栈的顺序存储结构及实现"><a class="anchor" href="#42栈的顺序存储结构及实现">#</a> 4.2. 栈的顺序存储结构及实现</h3><h4 id="421栈的结构定义"><a class="anchor" href="#421栈的结构定义">#</a> 4.2.1. 栈的结构定义</h4><p><img data-src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/%E6%A0%88%E7%9A%84%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89.png" alt="1"></p><h4 id="422进栈操作"><a class="anchor" href="#422进栈操作">#</a> 4.2.2. 进栈操作</h4><p><img data-src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/%E8%BF%9B%E6%A0%88%E6%93%8D%E4%BD%9C.png" alt="1"></p><h4 id="423出栈操作"><a class="anchor" href="#423出栈操作">#</a> 4.2.3. 出栈操作</h4><p><img data-src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/%E5%87%BA%E6%A0%88%E6%93%8D%E4%BD%9C.png" alt="1"></p><h3 id="43两栈共享空间"><a class="anchor" href="#43两栈共享空间">#</a> 4.3. 两栈共享空间</h3><p>做法就是在一个数组里面开辟两个栈，第一个栈的栈底为数组的始端，第二个栈的始端为数组的末端，两个栈如果增加元素，就是两端向中间延伸</p><p>结构定义</p><p><img data-src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/%E4%B8%A4%E6%A0%88%E5%85%B1%E4%BA%AB%E7%A9%BA%E9%97%B4%E7%9A%84%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89.png" alt="1"></p><p>进栈操作，就是多了一步判断是进栈 1 还是栈 2</p><p><img data-src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/%E8%BF%9B%E6%A0%88.png" alt="1"></p><p>出栈操作</p><p><img data-src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/%E5%87%BA%E6%A0%88.png" alt="1"></p><p>事实上，使用这样的数据结构，通常都是当两个栈的空间需求有相反关系时，也就是一个栈增长时，另一个栈在缩短的情况。</p><h3 id="44栈的链式存储结构及实现"><a class="anchor" href="#44栈的链式存储结构及实现">#</a> 4.4. 栈的链式存储结构及实现</h3><p>栈的链式存储结构称为链栈，通常对于链栈来说是不需要头结点的</p><h4 id="441链栈的结构定义"><a class="anchor" href="#441链栈的结构定义">#</a> 4.4.1. 链栈的结构定义</h4><p><img data-src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/%E9%93%BE%E6%A0%88%E7%9A%84%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89.png" alt="1"></p><h4 id="442进栈操作"><a class="anchor" href="#442进栈操作">#</a> 4.4.2. 进栈操作</h4><p>假设元素值为 e 的新结点是 s，top 为栈顶指针</p><p><img data-src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/%E9%93%BE%E6%A0%88%E7%9A%84%E8%BF%9B%E6%A0%88%E6%93%8D%E4%BD%9C.png" alt="1"></p><p><img data-src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/%E9%93%BE%E6%A0%88%E7%9A%84%E8%BF%9B%E6%A0%88%E6%93%8D%E4%BD%9C2.png" alt="1"></p><p>分析：总体思想是 top 位置不变，只是里面的内容变了，先把新结点的值给 s，然后把 top 赋给 s 的下一个，在然后把 top 给 s，然后 S 的数量加一，小 s 代表新结点，大 S 代表整个链栈</p><h4 id="443出栈操作"><a class="anchor" href="#443出栈操作">#</a> 4.4.3. 出栈操作</h4><p><img data-src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/%E9%93%BE%E6%A0%88%E7%9A%84%E5%87%BA%E6%A0%88%E6%93%8D%E4%BD%9C.png" alt="1"></p><p>分析：总体思想是把 s 里面的 top 值换了一个，先把 S 里面的 top 结点给要释放的 p，然后将 top 的下一个给 top，再然后释放 p，S 的数量减一</p><h4 id="444链栈的总结"><a class="anchor" href="#444链栈的总结">#</a> 4.4.4. 链栈的总结</h4><p>如果链栈的使用过程中元素变化不可预料，有时很小，有时很大，那么最好是用链栈，反之，如果它的变化再可控范围内，建议使用顺序栈会更好一些</p><h3 id="45栈的应用递归"><a class="anchor" href="#45栈的应用递归">#</a> 4.5. 栈的应用 —— 递归</h3><h4 id="451递归的定义"><a class="anchor" href="#451递归的定义">#</a> 4.5.1. 递归的定义</h4><p>我们把一个直接调用自己或通过一系列的调用语句间接地调用自己的函数，称为递归函数。每个递归定义必须至少有一个条件，满足时递归不再进行，即不再引用自身而是返回值退出</p><p>简单的说，就是在前行阶段，对于每一层递归，函数的局部变量、参数值以及返回地址都被压入栈中。在退回阶段，位于栈顶的局部变量、参数值和返回地址被弹出，用于返回调用层次中执行代码的其余部分，也就是恢复了调用的状态</p><h3 id="46栈的应用四则运算表达式求值"><a class="anchor" href="#46栈的应用四则运算表达式求值">#</a> 4.6. 栈的应用 —— 四则运算表达式求值</h3><h4 id="471后缀逆波兰表示法定义"><a class="anchor" href="#471后缀逆波兰表示法定义">#</a> 4.7.1. 后缀 (逆波兰) 表示法定义</h4><p>后缀表达式：所有的符号都是在要运算的数字后面出现；</p><p>计算过程：如 9 3 1 - 3 * + 10 2 / + ；规则：从左到右遍历表达式的每个数字和符号，遇到是数字就进栈，遇到是符号，就将处于栈顶的两个数字出栈，进行运算，运算结果进栈，一直到最终获得结果。例：9 3 1 进栈，遇到 -，3 和 1 出栈，做减法，2 进栈，3 进栈，遇到 *，2 和 3 出栈，6 进栈，遇到 +，9 和 6 出栈，15 进栈，10 和 2 进栈，遇到 /，10 和 2 出栈，5 进栈，遇到 +，15 和 5 出栈，20 入栈，得到结果</p><h4 id="472中缀表达式转后缀表达式"><a class="anchor" href="#472中缀表达式转后缀表达式">#</a> 4.7.2. 中缀表达式转后缀表达式</h4><p>我们把平时所用的标准四则运算表达式叫做中缀表达式，规则：从左到右遍历中缀表达式的每个数字的符号，若是数字就输出，即称为后缀表达式的一部分；若是符号，则判断其与栈顶符号的优先级，是右括号或优先级低于栈顶符号 (乘除优先加减) 则栈顶元素依次出栈并输出，并将当前符号进栈，一直到最终输出后缀表达式为止</p><p>例 9+(3-1) X 3+10/2 ：9 输出，+ 入栈，（入栈，3 输出，- 入栈，1 输出，此时该），但）不进栈，它和前面的（匹配，把（之后的符号全部输出，直到（出栈为止，然后 * 入栈，3 输出，此时到 + 了，因为 + 的优先级小于栈顶的 * 所以，* 输出，栈底的 + 也要输出，然后此时的遇到的 + 进栈，10 输出，遇到 /，/ 进栈，然后 2 输出，表达式遍历完毕，将栈里的符号依次输出，/ 先出，然后 + 再出</p><h3 id="48队列的定义"><a class="anchor" href="#48队列的定义">#</a> 4.8. 队列的定义</h3><p>队列是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。队列是一种先进先出的线性表，允许插入的一端称为队尾，允许删除的一端称为队头</p><h3 id="49循环队列"><a class="anchor" href="#49循环队列">#</a> 4.9. 循环队列</h3><h4 id="491队列顺序存储的不足"><a class="anchor" href="#491队列顺序存储的不足">#</a> 4.9.1. 队列顺序存储的不足</h4><p>队列顺序存储插入时比较方便，就直接在末尾插入就可以，但如果是要进行删除操作就不方便了，删除了第一个后，后面的每个元素都要向前移一个，时间复杂度为 O [n]，对这个我们也有一个解决办法，就是声明两个指针，一个 front 指向队头，一个 rear 指向队尾的后面一个，如果 front 和 rear 指向同一个的话，则为空队列，这下就可以不用移动元素，移动指针就是了。但现在又有个问题，就是前面出了队列的位置是空着的，但后面如果一直加的的话，迟早会超出数组界限，这种情况我们叫作假溢出，所以队列的顺序存储不行</p><h4 id="492循环队列定义"><a class="anchor" href="#492循环队列定义">#</a> 4.9.2. 循环队列定义</h4><p>解决假溢出的办法就是后面满了，就再从头开始，也就是头尾相连的循环，我们把队列的这种头尾相接的顺序存储结构称为循环队列</p><p>就是如果数组后面满了，就把 rear 指向第一个，也就是下标为 0 的位置，但此时问题又来了，当队列满了时，是 rear<mark>front，当队列为空队列时，也是 rear</mark>front，那么如何判断此时的队列是满的还是空的呢。</p><p>方法一：设立一个 flag 变量。当 front<mark>rear，且 flag</mark>0 时，队列为空，当 front<mark>rear，且 flag</mark>1 时，队列为满</p><p>方法二：当队列空时，条件就是 front=rear，当队列满时，我们修改其条件，保留一个元素空间，也就是说，队列满时，数组中还有一个空闲单元。</p><p>这里主要讨论第二种方法，队列满的条件是 (rear+l)% QueueSize==front. 取 % 的目的是为了整合 rear 和 front 大小为一个问题，计算队列长度公式为 (rear- front + QueueSize) % QueueSize</p><p>循环队列的顺序存储结构代码</p><p><img data-src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%9A%84%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89.png" alt="1"></p><p>循环队列初始化，就是把 front 和 rear 赋值为 0 就可以了，然后还有一个循环求队列长度</p><p>循环队列求队列长度，就是利用 (Q.rear-Q.front+MAXSIZE)% MAXSIZE; 这个公式来求队列长度</p><p>循环队列的入列操作</p><p><img data-src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E5%85%A5%E5%88%97.png" alt="1"></p><p>循环队列的出列操作</p><p><img data-src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%87%BA%E5%88%97.png" alt="1"></p><h3 id="410队列的链式存储结构及实现"><a class="anchor" href="#410队列的链式存储结构及实现">#</a> 4.10. 队列的链式存储结构及实现</h3><p>队列的链式存储结构，其实就是线性表的单链表，只不过它只能尾进头出而已，我们把它简称为链队列，为了操作上的方便，我们将队头指针指向链队列的头结点，而队尾指针指向终端结点，它的结构如下</p><p><img data-src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/%E9%93%BE%E9%98%9F%E5%88%97%E7%9A%84%E7%BB%93%E6%9E%84.png" alt="1"></p><p>链队列的入队操作</p><p><img data-src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/%E9%93%BE%E9%98%9F%E5%88%97%E7%9A%84%E5%85%A5%E9%98%9F%E6%93%8D%E4%BD%9C.png" alt="1"></p><p>链队列的出队操作</p><p><img data-src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/%E9%93%BE%E9%98%9F%E5%88%97%E7%9A%84%E5%87%BA%E9%98%9F%E6%93%8D%E4%BD%9C.png" alt="1"></p><h2 id="5串"><a class="anchor" href="#5串">#</a> 5. 串</h2><p>串是由另个或多个字符组成的有限序列，又名叫字符串，一般记为 s=&quot;a1a2a3......an&quot;，s 是串的名称，用双引号 (单引号也可以) 括起来的字符序列是串的值，串中的字符数目 n 称为串的长度</p><p>空格串，是只包含空格的串；子串与主串，串中的任意个数的连续字符组成的子序列称为该串的子串，相应的，包含子串的串称为主串，子串子啊主串中的位置就是子串的第一个字符在主串中的序号</p><h3 id="51串的抽象数据类型"><a class="anchor" href="#51串的抽象数据类型">#</a> 5.1. 串的抽象数据类型</h3><p>对串更多的操作是查找子串位置，得到指定位置子串，替换子串等操作，下面的就是判断已知串中是否存在一个与 T 相等的子串</p><p><img data-src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%B8%B2/%E4%B8%B2%E7%9A%84index%E6%93%8D%E4%BD%9C.png" alt="1"></p><h3 id="52串的存储结构"><a class="anchor" href="#52串的存储结构">#</a> 5.2. 串的存储结构</h3><h4 id="521串的顺序存储结构"><a class="anchor" href="#521串的顺序存储结构">#</a> 5.2.1. 串的顺序存储结构</h4><p>串的顺序存储结构是用一组地址连续的存储单元来存储串中的字符序列的，可用 c 语言里的 malloc 和 free 实现变长数组</p><h4 id="522串的链式存储结构"><a class="anchor" href="#522串的链式存储结构">#</a> 5.2.2. 串的链式存储结构</h4><p>这里的每一个结点可以不止放一个字符，以便减小内存消耗，但是每个结点存多少个，这是一个问题，总的来说不如顺序存储灵活，性能也不如顺序存储结构好</p><h3 id="53朴素的模式匹配算法"><a class="anchor" href="#53朴素的模式匹配算法">#</a> 5.3. 朴素的模式匹配算法</h3><p>在一段文字中匹配一个字符串的位置叫做串的模式匹配</p><p><img data-src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%B8%B2/%E4%B8%B2%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D.png" alt="1"></p><p><img data-src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%B8%B2/%E4%B8%B2%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D2.png" alt="1"></p><p>其中 T [0] 和 S [0] 存储的是串的长度，但这种算法很明显的效率低</p><h3 id="54kmp模式匹配算法"><a class="anchor" href="#54kmp模式匹配算法">#</a> 5.4.KMP 模式匹配算法</h3><h4 id="541kmp模式匹配算法原理"><a class="anchor" href="#541kmp模式匹配算法原理">#</a> 5.4.1.KMP 模式匹配算法原理</h4><p>主串 S='abcdefgab', 要匹配的 T='abcdex'。经我们仔细观察发现，对于匹配的子串 T 来说，'abcdex' 首字母 a 与后面的串 bcdex 中任意一个字符都不相等，也就是说，既然 a 不与自己后面的子串中任何一字符相等，那么在朴素算法中用 a 匹配 S 后面中一部分的字符的步骤是多余的。也就是说对于在子串中有与首位字符相等的字符，也是可以省略掉一部分不必要的判断步骤。在朴素算法中，主串的 i 值是不断地回溯来完成的，而我们的分析发现，这种回溯其实是不需要的 —— 正所谓好马不吃回头草，我们的 KMP 模式匹配算法就是为了让这没必要的回溯发生</p><p>既然 i 值不回溯，那么要考虑变化的就是 j 值了通过观察发现，这个 j 值的变化与主串没什么关系，关键在于 T 串中是否有重复的问题，我们可以把 T 串各位置的 j 值的变化定义为一个数组 next，那么 next 的长度就是 T 串的长度，于是我们可以得到下面的函数定义</p><p><img data-src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%B8%B2/next%E6%95%B0%E7%BB%84%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89.png" alt="1"></p><h4 id="542next数组值推导"><a class="anchor" href="#542next数组值推导">#</a> 5.4.2.next 数组值推导</h4><p>我们来一些实际例子来推导 next 数组值，如 T=abcabx</p><p>当 j=1 时，next [1]=0; 当 j=2 时，此时只有一个字符 a，属于其他情况，next [2]=1; 当 j=3 时，j 由 1 到 j-1 的字符为 ab，没有重复的，属于其他情况，next [3]=1；当 j=4 时，同上，next [4]=1; 当 j=5 时，j 从 1 到 j-1 得到的串是 abca，有一个重复的，next [5]=2; 当 j=6 时，得到的字符是 abcab，有两个重复的，next [6]=3，我们可以根据经验得到，如果前后缀一个字符相等，k 值是 2，两个字符 k 值是 3，n 个相等 k 值就是 n+1。</p><h4 id="543kmp模式匹配算法实现"><a class="anchor" href="#543kmp模式匹配算法实现">#</a> 5.4.3.KMP 模式匹配算法实现</h4><p>首先计算出与 T 匹配的 next 数组</p><p><img data-src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%B8%B2/%E8%AE%A1%E7%AE%97next%E6%95%B0%E7%BB%84.png" alt="1"></p><p>然后是对朴素算法的改进</p><p><img data-src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%B8%B2/kmp.png" alt="1"></p><p><img data-src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%B8%B2/kmp1.png" alt="1"></p><h3 id="55堆串"><a class="anchor" href="#55堆串">#</a> 5.5. 堆串</h3><p>字符串包括串名与串值两部分，串名用符号存储，而串值采用堆串存储。</p><p>符号表：所有的串名的存储映像构成一个符号表。借助此结构可以在串名和串值之间建立一个对应关系，称为串名的存储映像。</p><p>堆串：以一组地址连续的存储单元顺序存放串中的字符，但他们的存储空间是在程序执行过程中动态分配的 (malloc)。</p><p>系统将一个地址连续、容量很大的存储空间作为字符串的可用空间，每当建立一个新串时，系统就从该空间中分配一个大小和字符串长度相同的空间用于存储新串的串值</p><p><img data-src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%B8%B2/%E5%A0%86%E4%B8%B2%E7%9A%84%E5%AD%98%E5%82%A8%E6%98%A0%E5%83%8F.png" alt="1"></p><p>堆串的定义</p><p><img data-src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%B8%B2/%E5%A0%86%E4%B8%B2%E7%9A%84%E5%AE%9A%E4%B9%89.png" alt="1"></p><p>其中，len 表示串的长度，ch 指示串的起始地址</p><p>堆串的插入函数实现</p><p><img data-src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%B8%B2/%E5%A0%86%E4%B8%B2%E7%9A%84%E6%8F%92%E5%85%A5%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0.png" alt="1"></p><p>主要思想就是开辟一个中间变量，然后把 s 的前 pos 个赋给 temp，然后接下来把 t 赋给 temp 的 pos 以后的，最后再把 s 剩下的继续赋给 temp，然后将 s 的字符域释放，再将 temp 赋给 s 的字符域</p><p>堆串赋值函数的实现</p><p><img data-src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%B8%B2/%E5%A0%86%E4%B8%B2%E8%B5%8B%E5%80%BC%E5%87%BD%E6%95%B0.png" alt="1"></p><p>主要思想是先把 s 的字符域释放，后面再根据新字符的长度重新分配空间</p><p>注意：定长顺序串和堆串操作基本思路相同，区别在于定长顺序串的长度是固定的，而堆串的串值空间是申请的，是统一管理和分配的可用空间，因此二者的操作区别在于空间的申请方法。</p><h3 id="56块链串"><a class="anchor" href="#56块链串">#</a> 5.6. 块链串</h3><p>由于串也是一种线性表，因此也可以采用链式存储。一个链表放一个串值，每个结点既可以放一个字符，也可以放多个字符，每个结点称为块，整个链表称为块链结构，为便于操作，再增加一个尾指针，块链结构定义如下</p><p><img data-src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%B8%B2/%E5%9D%97%E9%93%BE%E4%B8%B21.png" alt="1"></p><p><img data-src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%B8%B2/%E5%BF%AB%E9%93%BE%E4%B8%B22.png" alt="1"></p><p>链表中的结点分成两个域 data 和 link，其中结点大小是指 data 域中存放字符的个数，链域大小是指 link 域中占用字符的个数。如果一个结点大小为 4，链域大小为 2，根据存储密度等于串值占用的存储位 / 实际为串分配的存储位计算，该字符串的存储密度位 2/3 (4/6)</p><h3 id="57总结"><a class="anchor" href="#57总结">#</a> 5.7. 总结</h3><p>字符串是一种特定的线性表，其特殊性就在于组成线性表的每个元素就是一个单字符，字符串常用的存储方式有三种：定长顺序串，堆串，块链串，定长顺序串以一维数组作为静态存储结构，运算实现同顺序表，堆串以动态分配的方式产生一组地址连续的存储单元以顺序存放串中的字符，运算实现通顺序串。块链串以链表作为存储结构，运算数实现同链表</p><h2 id="6数组与广义表"><a class="anchor" href="#6数组与广义表">#</a> 6. 数组与广义表</h2><p>数组与广义表可看作是一种扩展的线性数据结构，是线性表的推广</p><h3 id="61数组的定义与运算"><a class="anchor" href="#61数组的定义与运算">#</a> 6.1. 数组的定义与运算</h3><p>一维数组即线性表，二维数组为 “其数据元素为一维数组的线性表”，就是数组的每一列就是一维数组的一个数据元素，这个数据元素也是一维数组，当然把行向量看成一个数据元素也是可以的，依次类推，三维数组就是数据元素为二维数组的线性表</p><p><img data-src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%B9%BF%E4%B9%89%E8%A1%A8/%E6%95%B0%E7%BB%84%E7%9A%84%E5%AE%9A%E4%B9%89.png" alt="1"></p><h3 id="62数组的顺序存储与实现"><a class="anchor" href="#62数组的顺序存储与实现">#</a> 6.2. 数组的顺序存储与实现</h3><p>因为只要数组的维数和各维的长度确定，数组中的元素的个数就是确定的，数组的基本操作不涉及数组结构的变化，所以对于数组而言，采用顺序存储表示比较合适。且数组的下标都从 1 开始</p><p><img data-src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%B9%BF%E4%B9%89%E8%A1%A8/%E4%B8%89%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="1"></p><p>三维数组元素的标号由三个数字表示，即行、列、纵三个方向。a142 表示第一行，第四列，第二纵的元素。如果对 A3x4x 采用以行为主序的方法，即下标变化最慢，纵下标变化最快，则顺序为 a11.a112.a21.....a331,a332,a341,a342。如果采用以纵为主序的方法存放，即纵下标变化最慢，行下标变化最快，则顺序为 a11,a211,a311,a121,a221,a321.....a132,a232,a332,a142,a242,a342</p><h4 id="621一维数组地址的计算"><a class="anchor" href="#621一维数组地址的计算">#</a> 6.2.1. 一维数组地址的计算</h4><p>一维数组中的元素只需要一个下标，其实质是线性表，存储方法与普通线性表存储方法相同，数组中每个元素占 size 个存储单元，则元素 ai 的存储地址为 Loc (A [i])=Loc (A [1])+(i-1) xsize，其中 A [1] 为首元素的地址</p><h4 id="622二维数组的地址计算"><a class="anchor" href="#622二维数组的地址计算">#</a> 6.2.2. 二维数组的地址计算</h4><p>以 Amxn 为例，每个元素占 size 个存储单元则 aij 的地址为 LOC (A [i][j])=LOC (A [1][1])+(nx (i-1)+j-1) xsize; 因为 aij 是第 i 行，第 j 列，ai 行前面有 nx (i-1) 个元素，ai 这行有 j-i 个元素</p><h4 id="623三维数组的地址计算"><a class="anchor" href="#623三维数组的地址计算">#</a> 6.2.3. 三维数组的地址计算</h4><p>三维数组 A [1..r,1...m,1...n] 可以看成是 r 个 mxn 的二维数组，如下图所示，假设每个元素占 size 个存储单元，采用以行为主的方法存放，即行下标 r 变化最慢，纵下标 n 变化最快，显然 ai11 的地址为 Loc (A [i][1][1])=Loc (A [1][1][1])+(i-1) xmxn; 因为在该元素之前，有 i-1 个 mxn 的二维数组。由 ai11 的地址和二维数组的地址计算公式，不难得到三维数组任意元素 aijk 的地址计算公式</p><p><img data-src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%B9%BF%E4%B9%89%E8%A1%A8/%E4%B8%89%E7%BB%B4%E6%95%B0%E7%BB%84%E5%9C%B0%E5%9D%80%E8%AE%A1%E7%AE%97%E5%85%AC%E5%BC%8F.png" alt="1"></p><p><img data-src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%B9%BF%E4%B9%89%E8%A1%A8/%E4%B8%89%E7%BB%B4%E6%95%B0%E7%BB%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="1"></p><p>其中要注意 ijk 的范围，如果将三维数组推广到一般情况，即用 j1,j2,j3, 代替数组下标 i,j,k, 并且 j1,j2,j3 的下限分别为 c1,c2,c3，上限分别为 d1,d2,d3, 每个元素占 size 个存储单元，则三维数组中任意元素 aj1j2j3 的地址计算公式为</p><p><img data-src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%B9%BF%E4%B9%89%E8%A1%A8/%E4%B8%89%E7%BB%B4%E6%95%B0%E7%BB%84%E5%9C%B0%E5%9D%80%E8%AE%A1%E7%AE%97%E5%85%AC%E5%BC%8F%E6%8E%A8%E5%B9%BF.png" alt="1"></p><p>其中，d2-c2+1 就相当于 m，d3-c3+1 就相当于 n，且这两项与 j1,j2,j3 无关，所以地址与 j1,j2,j3 成线性关系</p><h4 id="624n维数组地址计算"><a class="anchor" href="#624n维数组地址计算">#</a> 6.2.4.n 维数组地址计算</h4><p><img data-src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%B9%BF%E4%B9%89%E8%A1%A8/n%E7%BB%B4%E6%95%B0%E7%BB%84%E5%9C%B0%E5%9D%80%E7%9A%84%E8%AE%A1%E7%AE%97%E5%85%AC%E5%BC%8F.png" alt="1"></p><h3 id="63特殊矩阵的压缩存储"><a class="anchor" href="#63特殊矩阵的压缩存储">#</a> 6.3. 特殊矩阵的压缩存储</h3><h4 id="631规律分布的特殊矩阵"><a class="anchor" href="#631规律分布的特殊矩阵">#</a> 6.3.1. 规律分布的特殊矩阵</h4><p>元素分布具有一定规律的矩阵称为规律分布的特殊矩阵，如三角矩阵 (方阵的上或下三角全为 0)，这类矩阵中元素分布的规律可以用数学公式来反映，通常利用这些规律将其压缩存储于一维数组中，已知矩阵 A 中元素下标 i 和 J, 作为转换函数 f 的自变量，计算出相应一维内存空间的地址值 K，即 A [i][j]=B [K], 实现了原矩阵到压缩存储后的一维数组的存储映射</p><h4 id="632三角矩阵"><a class="anchor" href="#632三角矩阵">#</a> 6.3.2. 三角矩阵</h4><p>三角矩阵大体分为三类：下三角矩阵、上三角矩阵和对称矩阵。上三角矩阵就是对角线 (左上到右下) 下的元素全相等，经典情况是全为 0；下三角就是对角线以上的元素全相等，经典情况是全为 0；如果关于对角线对称的元素相等 ，则称为此矩阵为对称矩阵。</p><p>例，将一个 nxn 的下三角矩阵压缩存储，下三角矩阵的压缩存储原则是只存储下三角的非零元素，不存上三角的 0 元素，按行主序进行存储，得到的序列为 a11,a21,a22,a31...ann，总共个数为 nx (n+1)/2，所以可将这些元素存储到一个长度为这么长的一维数组 B 里，这些元素在数组 B 中的下标为 Loc [i,j]=Loc [1,1]+(ix (i-1)/2+j-1)，ix (i-1)/2 为前 i-1 行的元素个数，j-1 为第 i 行中 aij 前面的元素个数</p><p>对于对称矩阵，因其元素满足 aij=aji，我们可以为每一对相等的元素分配一个存储空间，即只存上三角或者下三角矩阵，从而将 n2 个元素压缩到 nx (n+1)/2 个空间中</p><p>实际应用中，我们更关心下标与元素的对应关系，如果将 A [i][j] 存储到 B [k]，我们关心的是如何通过 i 和 j 计算出 k，下面就是下三角矩阵的压缩</p><p><img data-src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%B9%BF%E4%B9%89%E8%A1%A8/%E4%B8%8B%E4%B8%89%E8%A7%92%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8E%8B%E7%BC%A9.png" alt="1"></p><h4 id="633带状矩阵"><a class="anchor" href="#633带状矩阵">#</a> 6.3.3. 带状矩阵</h4><p>在矩阵中的所有非零元素都集中在以主对角线为中心的带状区域中，最常见的是三对角带状矩阵</p><p><img data-src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%B9%BF%E4%B9%89%E8%A1%A8/%E4%B8%89%E5%AF%B9%E8%A7%92%E5%B8%A6%E7%8A%B6%E7%9F%A9%E9%98%B5.png" alt="1"></p><p>其特点为，在以下条件下 aij 为非零，其他元素均为 0</p><p><img data-src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%B9%BF%E4%B9%89%E8%A1%A8/%E4%B8%89%E5%AF%B9%E8%A7%92%E5%B8%A6%E7%8A%B6%E7%9F%A9%E9%98%B5%E7%9A%84%E7%89%B9%E7%82%B9.png" alt="1"></p><p>三对角带状矩阵的压缩存储原则为：将带状区域上的非 0 元素按行序存储。其压缩存储方法如下。</p><p>首先确定存储该矩阵所需的一维向量空间的大小，据观察可知，三对角带状矩阵只有第一行和最后一行只有两个非 0 元素，其余行都有三个非 0 元素，所以元素个数为 2+2+(n-2) x3=3n-2。然后确定非 0 元素在一维数组空间中的地址，Loc (A [i][j])=Loc (A [1][1])+(2 (i-1)+j-1) xsize，前 i-1 行的 元素个数为 3x (i-1)-1，除第一行外都有三个元素，第 i 行的元素个数为 j-i+1，因为 j-i 只会是 0，1，-1 三种值 (这才符合三对角带状矩阵的特征)，所以加起来就是 2 (i-1)+j-1</p><h4 id="634稀疏矩阵"><a class="anchor" href="#634稀疏矩阵">#</a> 6.3.4. 稀疏矩阵</h4><p>稀疏矩阵是指矩阵中大部分元素都为 0，从直观上讲，当非 0 元素个数低于总元素的 30% 时，这样的矩阵为稀疏矩阵</p><p>1. 稀疏矩阵的三元组存储表示</p><p>对于稀疏矩阵的压缩存储，采取只存储非 0 元素的方法，由于稀疏矩阵中非 0 元素 aij 的分布没有规律，因此，在存储非 0 元素值得同时还需要存储该非 0 元素在矩阵中所处的行和列，这就是稀疏矩阵的三元组表示法。为了处理方便，将稀疏矩阵中的非 0 元素对应的三元组按 “行序为主序” 的一维结构体数组进行存放，将矩阵的每一行 (行由小到大) 的全部非 0 元素的三元组按列号递增存放，由此得到三元组表</p><p><img data-src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%B9%BF%E4%B9%89%E8%A1%A8/%E4%B8%89%E5%85%83%E7%BB%84%E8%A1%A8.png" alt="1"></p><p>稀疏三元组表的类型定义</p><p><img data-src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%B9%BF%E4%B9%89%E8%A1%A8/%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5%E4%B8%89%E5%85%83%E7%BB%84%E8%A1%A8%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89.png" alt="1"></p><p>三元组表实现稀疏矩阵的转置</p><p>经典算法</p><p><img data-src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%B9%BF%E4%B9%89%E8%A1%A8/%E7%9F%A9%E9%98%B5%E8%BD%AC%E7%BD%AE%E7%9A%84%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95.png" alt="1"></p><p>思想就是一行一行的来将元素赋给转置后的位置</p><p>用三元组表实现稀疏矩阵的转置：思想为将矩阵 source 的三元组表 A 的行、列互换就可以得到中的元素，但转置后的三元组表不是以 &quot;行序为主序&quot; 存储的，为保证转置后的矩阵的三元表 B 也是以 &quot;行序为主序&quot; 进行存放，则需要对转置后的三元组表按 B 的行下标以递增顺序重新排列，可以看出，转置简单，但排序难</p><p>方法一：列序递增转置法，思想：采用按照被转置矩阵三元组表 A 的列序 (即转置后三元组表 B 的行序) 递增的顺序进行转置，并依次送入转置后矩阵的三元组表 B 中，这样一来，转置后矩阵的三元组表 B 恰好是以 “行序为主序” 的，具体做法，先找出所有列序为 1 的三元组，转置后按顺序送到三元组表 B 中，为实现处理附设一个当前转置后元素应放入三元组表 B 中的位置下标。j 初值为一，当处理完一个元素后加 1；</p><p><img data-src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%B9%BF%E4%B9%89%E8%A1%A8/%E5%88%97%E5%BA%8F%E9%80%92%E5%A2%9E%E8%BD%AC%E7%BD%AE%E6%B3%95.png" alt="1"></p><p><img data-src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%B9%BF%E4%B9%89%E8%A1%A8/%E5%88%97%E5%BA%8F%E9%80%92%E5%A2%9E2.png" alt="1"></p><p>方法二：一次定位快速转置法。方法一比较耗时是因为需要反复对三元组表 A 扫描和双重 for 循环，所以我们要减少耗时就需要去掉双重 for 循环，只用一次循环就使 A 中所有非 0 元一次定位直接放到三元组表的正确位置。为了能将被转置三元数组表 A 中的元素一次定位到三元组表 B 的正确位置上，需要预先计算以下数据。待转置矩阵三元组表 A 中的每一列中非零元素的总个数，即转置后矩阵三元组表 B 的每一行中非 0 元素的个数。待转置矩阵每一列中第一个非 0 元素在三元组表 B 中的正确位置，即转置后矩阵每一行中第一个非 0 元素在三元组表 B 中的正确位置，为此，需要设两个数组分别为 num [] 和 position []，其中 num [col] 用来存放三元组表 A 第 col 列中非 0 元素总个数 (三元组表 B 第 col 行中非 0 元素总个数)，position [col] 用来存放转置前三元组表 A 中第 col 列 (转置后三元组表 B 中第 col 行) 中第一个非 0 元素在三元组表 B 中的存储位置</p><p><img data-src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%B9%BF%E4%B9%89%E8%A1%A8/%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E8%BD%AC%E7%BD%AE1.png" alt="1"></p><p><img data-src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%B9%BF%E4%B9%89%E8%A1%A8/%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E8%BD%AC%E7%BD%AE2.png" alt="1"></p><p>2. 稀疏矩阵的链式存储结构：十字链表</p><p>虽然用三元组表可以节约空间，而且使得矩阵某些运算的时间效率优于经典算法，但是如果要进行矩阵加法，减法，乘法等运算时，有时矩阵中非零元素的位置和个数会发生很大的变化，这样就会造成大量元素的移动。为了防止这种移动，我们采用链表，它能灵活的插入因运算而产生的新的非零元素，删除因运算而产生的新的零元素，实现矩阵的各种运算</p><p>十字链表的存储表示：在十字链表中，矩阵的每一个非零元素用一个结点表示，该结点除了 (row,col,value) 外，还要添加以下两个链域，right 用于链接同一行中的下一个非零元素，down 用于链接同一列中的下一个非零元素</p><p>这样的话。矩阵中任一非零元素 M [i][j] 既在第 i 行的行链表上，也在第 j 列的列链表上，然后再附设一个存放所有行链表的头指针的一维数组和一个存放所有列链表的头指针的一维数组，完整的十字链表的结构如下图所示</p><p><img data-src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%B9%BF%E4%B9%89%E8%A1%A8/%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8%E8%A1%A8%E7%A4%BA.png" alt="1"></p><p>十字链表的类型定义如下</p><p><img data-src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%B9%BF%E4%B9%89%E8%A1%A8/%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89.png" alt="1"></p><p>十字链表算法实现</p><p>思想：1、读入稀疏矩阵的行数、列数、非零元的个数。2、动态申请行链表的头指针向量、列链表的头指针向量。3、逐个读入非零元素，分别插入行链表、列链表</p><p><img data-src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%B9%BF%E4%B9%89%E8%A1%A8/%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8%E5%88%9B%E5%BB%BA1.png" alt="1"></p><p><img data-src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%B9%BF%E4%B9%89%E8%A1%A8/%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8%E5%88%9B%E5%BB%BA2.png" alt="1"></p><p>整个流程大致如下：先是读取行数、列数和非零元素的个数，然后动态分配 row_head 和 col_head 的空间大小，然后再对 row_head 和 col_head 进行初始化，全部初始化为 NULL，然后再进行输入读取，采用了先生成结点 p，并把值赋好，然后再来插入结点，插入结点分为了行插入和列插入，插入结点时先判断这个结点是否存在，若不存在则可直接将 row-head 和 col_head 对应的行 (列) 进行赋值，若存在 (以行插入为例)，则判断列的位置，这时就需要一个中间判断变量 q，将它赋值为 row_head [i]，即对应的行，然后再往 right 遍历，直到满足 q 的 right 的 col 大于输入的列数 j，然后就把 q 的 right 赋值给 p 的 right，再把 p 赋值给 q 的 right</p><h3 id="64广义表"><a class="anchor" href="#64广义表">#</a> 6.4. 广义表</h3><p>广义表和线性表差不多，只是广义表的元素既可以是单个元素，也可以是一个广义表，通常记作 GL=(d1,d2,d3,...,dn)。GL 是广义表的名称，通常广义表的名字用大写字母表示。n 是广义表长度，若 di 是一个广义表，则称 di 是广义表 GL 的一个子表，在广义表中，d1 是广义表表头，而其余部分组成的表称为广义表的表尾，以下给出一些广义表的例子</p><p><img data-src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%B9%BF%E4%B9%89%E8%A1%A8/%E5%B9%BF%E4%B9%89%E8%A1%A8%E7%9A%84%E4%BE%8B%E5%AD%90.png" alt="1"></p><h4 id="641广义表的存储结构"><a class="anchor" href="#641广义表的存储结构">#</a> 6.4.1. 广义表的存储结构</h4><p>因为广义表中的数据元素既可以是单个元素，也可以是子表，所以通常用链式存储结构来表示广义表</p><p>1. 广义表的头尾链表存储结构</p><p>一个表结点可由三个域构成：标志域、指向表头的指针域和指向表尾的指针域，而元素结点只需要两个域，标志域和值域</p><p><img data-src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%B9%BF%E4%B9%89%E8%A1%A8/%E5%B9%BF%E4%B9%89%E8%A1%A8%E7%BB%93%E6%9E%84.png" alt="1"></p><p><img data-src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%B9%BF%E4%B9%89%E8%A1%A8/%E5%B9%BF%E4%B9%89%E8%A1%A8%E7%9A%84%E5%A4%B4%E5%B0%BE%E5%9F%9F%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E4%BE%8B%E5%AD%90.png" alt="1"></p><p>2. 广义表的同层结点链存储结构</p><p>在这种结构中，无论是原子结点还是表结点均由三个域构成。其结构如下图所示</p><h3 id="66总结"><a class="anchor" href="#66总结">#</a> 6.6. 总结</h3><h4 id="661主要知识点"><a class="anchor" href="#661主要知识点">#</a> 6.6.1. 主要知识点</h4><p>数组的基本知识点</p><p>1.n 维数组可以看成是一个每个数据元素都是 n-1 维数组的线性表</p><p>特殊矩阵的压缩存储</p><p>1. 元素分布有规律，只需找到对应规律的数组函数，将二维矩阵 A 中元素的下标作为转换函数 f 的自变量，计算出到一维数组内存空间的地址值 K，就实现了原二维数组压缩到一维数组的存储映射</p><p>2. 非零元素非常少的稀疏矩阵，只存非零元素所在的行号、列号和值来实现压缩存储，压缩存储即可以采用三元组表，也可以采用十字链表</p><p>广义表</p><p>1. 广义表是 n 个数据元素的有限序列，其中的元素既可以是单个元素，也可以是一个广义表，广义表的定义具有递归性，其常用操作通常采用递归实现</p><p>2. 一个非空的广义表 GL 可以看成是由表头和表尾构成，表中的第一个元素称为 GL 的表头，其余元素合称维 GL 的表尾</p><h2 id="7树"><a class="anchor" href="#7树">#</a> 7. 树</h2><h3 id="71树的定义"><a class="anchor" href="#71树的定义">#</a> 7.1. 树的定义</h3><p>树是 n 个结点的有限集，n=0 时称为空树。在任何一颗非空树中，有且仅有一个特定的称为根的结点，当 n&gt;1 时，其余结点可分为 m 个互不相交的有限集 T1,T2....、Tm, 其中每一个集合本身又是一棵树，并且称为根的子树</p><p>对于树的定义还需要强调两点：1.n&gt;0 时根结点时唯一的，不可能存在多个根结点。2.m&gt;0 时，子树的个数没有限制，但它们一定是互不相交的</p><h4 id="711结点分类"><a class="anchor" href="#711结点分类">#</a> 7.1.1. 结点分类</h4><p>树的结点包含一个数据元素及若干指向其子树的分支。结点拥有的子树数称为结点的度。度为 0 的结点称为叶结点或终端结点；度不为 0 的结点称为非终端结点或分支结点。除根结点外，分支结点叶称为内部结点。树的度是树内各结点的度的最大值</p><h4 id="712结点间关系"><a class="anchor" href="#712结点间关系">#</a> 7.1.2. 结点间关系</h4><p>结点的子树的根称为该结点的孩子，相应的，该结点称为孩子的双亲。同一个双亲的孩子之间互称兄弟。结点的祖先是从根到该结点所经分支上的所有结点，反之，以某结点为根的子树中的任一结点都称为该结点的子孙</p><p><img data-src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E7%BB%93%E7%82%B9%E9%97%B4%E5%85%B3%E7%B3%BB.png" alt="1"></p><h4 id="713树的其他相关概念"><a class="anchor" href="#713树的其他相关概念">#</a> 7.1.3. 树的其他相关概念</h4><p>结点的层次从根开始定义，根为第一层，树中结点的最大层次称为树的深度或高度</p><p>如果将树中结点的子树看成从左至右是有次序的，不能互换的，则称该树为有序树，否则称为无序树</p><p>森林是 m 棵互不相交的树的集合。对树中的每个结点而言，其子树的集合即为森林</p><h3 id="72树的存储结构"><a class="anchor" href="#72树的存储结构">#</a> 7.2. 树的存储结构</h3><h4 id="721双亲表示法"><a class="anchor" href="#721双亲表示法">#</a> 7.2.1. 双亲表示法</h4><p>我们假设以一组连续空间存储树的结点，同时在每个结点中，附设一个指示器指示其双亲结点到链表中的位置，也就是说每个结点除了知道自己是谁外，还知道它的双亲在哪里</p><p><img data-src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E5%8F%8C%E4%BA%B2%E8%A1%A8%E7%A4%BA%E6%B3%951.png" alt="1"></p><p><img data-src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E5%8F%8C%E4%BA%B2%E8%A1%A8%E7%A4%BA%E6%B3%952.png" alt="1"></p><p>由于根结点是没有双亲的，所以我们约定根结点的位置域设置为 - 1，这就意为着，我们所有的结点都存有它的双亲的位置</p><p><img data-src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E5%8F%8C%E4%BA%B2%E8%A1%A8%E7%A4%BA%E6%B3%953.png" alt="1"></p><h4 id="722孩子表示法"><a class="anchor" href="#722孩子表示法">#</a> 7.2.2. 孩子表示法</h4><p>由于树中每个结点可能有多棵子树，可以考虑用多重链表，即每个结点有多个指针域，其中每个指针指向一棵子树的根结点，我们把这种方法叫做多重链表表示法，但树的每个结点的度，也就是它的孩子个数不一定相等，为了解决这个问题，有以下两种方法</p><p>一种是指针域的个数就等于树的度，树的度是树各个结点度的最大值，但这种方法在树中各结点的度相差很大时对空间的浪费很大</p><p>一种是每个结点指针域的个数就等于该结点的度，我们专门取一个位置来存储结点指针域的个数，但这种方法要知道每个结点的度数，在运算上就会带来时间上的损耗</p><p>所以我们采用孩子表示法，具体办法是，把每个结点的孩子结点排列起来，以单链表作存储结构，则 n 个结点有 n 个孩子链表，如果是叶子结点则此单链表为空，然后 n 个头指针又组成一个线性表，采用顺序存储结构，存放进一个一维数组中</p><p><img data-src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E5%AD%A9%E5%AD%90%E8%A1%A8%E7%A4%BA%E6%B3%952.png" alt="1"></p><p><img data-src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E5%AD%A9%E5%AD%90%E8%A1%A8%E7%A4%BA%E6%B3%95.png" alt="1"></p><p>为此，我们需要设计两种结点结构，一种是孩子链表的孩子结点，其中 child 是数据域，用来存储某个结点在表头数组中的下标。next 是指针域，用来存储指向某结点的下一个孩子结点的指针</p><p>另一个是表头数组的表头结点，其中 data 是数据域，存储某结点的数据信息，firstchild 是头指针域，存储该结点的孩子链表的头指针</p><p><img data-src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E5%AD%A9%E5%AD%90%E8%A1%A8%E7%A4%BA%E6%B3%95%E7%9A%84%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%891.png" alt="1"></p><p><img data-src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E5%AD%A9%E5%AD%90%E8%A1%A8%E7%A4%BA%E6%B3%95%E7%9A%84%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%892.png" alt="1"></p><h4 id="723孩子兄弟表示法"><a class="anchor" href="#723孩子兄弟表示法">#</a> 7.2.3. 孩子兄弟表示法</h4><p>任意一棵树，它的结点的第一个孩子如果存在就是唯一的，它的右兄弟如果存在也是唯一的，因此，我们设置两个指针，分别指向该结点的第一个孩子和此结点的右兄弟</p><p><img data-src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E5%AD%A9%E5%AD%90%E5%85%84%E5%BC%9F%E8%A1%A8%E7%A4%BA%E6%B3%95.png" alt="1"></p><p><img data-src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E5%AD%A9%E5%AD%90%E5%85%84%E5%BC%9F%E6%B3%95%E5%9B%BE%E7%A4%BA.png" alt="1"></p><p>这种方法表示的最大好处就是把一棵树变成了二叉树</p><h3 id="73二叉树"><a class="anchor" href="#73二叉树">#</a> 7.3. 二叉树</h3><p>二叉树是 n 个结点的有限集合，该集合或者为空集 (称为空二叉树)，或者由一个根结点和两颗互不相交的、分别称为根结点的左子树和右子树的二叉树组成</p><h4 id="731二叉树特点"><a class="anchor" href="#731二叉树特点">#</a> 7.3.1. 二叉树特点</h4><p>每个结点最多有两棵子树，所以二叉树中不存在度大于 2 的结点</p><p>左子树和右子树是有顺序的，次序不能任意颠倒</p><p>即使树中某结点只有一颗子树，也要区分它是左子树还是右子树</p><h4 id="732特殊二叉树"><a class="anchor" href="#732特殊二叉树">#</a> 7.3.2. 特殊二叉树</h4><p>1. 斜树。顾名思义，斜树一定是要斜的，所有的结点都只有左子树的二叉树叫左斜树。所有结点都是只有右子树的二叉树叫右斜树，这两者统称为斜树，斜树每层只有一个结点，结点的个数与二叉树的深度相同</p><p>2. 满二叉树。在一颗二叉树中，如果所有的分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树</p><p>特点有，叶子只能出现在最下一层，出现在其他层不可能达成平衡</p><p>非叶子结点的度一定是 2，否则就缺胳膊少腿了</p><p>在同样深度的二叉树中，满二叉树的结点个数最多，叶子树最多</p><p>3. 完全二叉树</p><p>对一棵具有 n 个结点的二叉树按层序编号，如果编号为 i 的结点与同样深度的满二叉树中编号为 1 的结点在二叉树中位置完全相同，则这棵二叉树被称为完全二叉树 (满二叉树一定是完全二叉树，但完全二叉树不一定是满二叉树，因为完全二叉树可能缺胳膊少腿)，注意按层序编号，即使没有存在的结点也要算</p><p><img data-src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%A4%BA%E4%BE%8B.png" alt="1"></p></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2022-05-12 20:43:44" itemprop="dateModified" datetime="2022-05-12T20:43:44+08:00">2022-05-12</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="Greg yang 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="Greg yang 支付宝"><p>支付宝</p></div><div><img data-src="/images/paypal.png" alt="Greg yang 贝宝"><p>贝宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>Greg yang <i class="ic i-at"><em>@</em></i></li><li class="link"><strong>本文链接：</strong> <a href="https://github.com/Greg267/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="数据结构">https://github.com/Greg267/数据结构/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/Ajax/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva1.sinaimg.cn&#x2F;mw690&#x2F;008qflI6ly8h25fuse10xj31900u0go8.jpg" title="Ajax"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i></span><h3>Ajax</h3></a></div><div class="item right"><a href="/javascipt/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva1.sinaimg.cn&#x2F;mw690&#x2F;008qflI6ly8h25g82ocylj308c04pq2u.jpg" title="JavaScript"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i></span><h3>JavaScript</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%AA%E8%AE%BA"><span class="toc-number">1.</span> <span class="toc-text">1. 数据结构绪论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E6%9C%AF%E8%AF%AD"><span class="toc-number">1.1.</span> <span class="toc-text">1.1. 基本概念和术语</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84%E5%92%8C%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.</span> <span class="toc-text">1.2. 逻辑结构和物理结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#121%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.1.</span> <span class="toc-text">1.2.1 逻辑结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#122%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.2.</span> <span class="toc-text">1.2.2. 物理结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.</span> <span class="toc-text">1.3. 抽象数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#131%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.1.</span> <span class="toc-text">1.3.1. 数据类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#132%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.2.</span> <span class="toc-text">1.3.2. 抽象数据类型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E7%AE%97%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">2. 算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#21%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E7%9A%84%E8%A6%81%E6%B1%82"><span class="toc-number">2.1.</span> <span class="toc-text">2.1. 算法设计的要求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22%E5%87%BD%E6%95%B0%E7%9A%84%E6%B8%90%E8%BF%91%E5%A2%9E%E9%95%BF"><span class="toc-number">2.2.</span> <span class="toc-text">2.2. 函数的渐近增长</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22%E7%AE%97%E6%B3%95%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">2.3.</span> <span class="toc-text">2.2. 算法时间复杂度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#221%E6%8E%A8%E5%AF%BC%E5%A4%A7o%E9%98%B6"><span class="toc-number">2.3.1.</span> <span class="toc-text">2.2.1. 推导大 O 阶</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#222%E5%B8%B8%E6%95%B0%E9%98%B6"><span class="toc-number">2.3.2.</span> <span class="toc-text">2.2.2. 常数阶</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#223%E7%BA%BF%E6%80%A7%E9%98%B6"><span class="toc-number">2.3.3.</span> <span class="toc-text">2.2.3. 线性阶</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#224%E5%AF%B9%E6%95%B0%E9%98%B6"><span class="toc-number">2.3.4.</span> <span class="toc-text">2.2.4. 对数阶</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#225%E5%B9%B3%E6%96%B9%E9%98%B6"><span class="toc-number">2.3.5.</span> <span class="toc-text">2.2.5. 平方阶</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23%E5%B8%B8%E8%A7%81%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">2.4.</span> <span class="toc-text">2.3. 常见的时间复杂度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24%E6%9C%80%E5%9D%8F%E6%83%85%E5%86%B5%E4%B8%8E%E5%B9%B3%E5%9D%87%E6%83%85%E5%86%B5"><span class="toc-number">2.5.</span> <span class="toc-text">2.4. 最坏情况与平均情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25%E7%AE%97%E6%B3%95%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">2.6.</span> <span class="toc-text">2.5. 算法空间复杂度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="toc-number">3.</span> <span class="toc-text">3. 线性表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#31%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.1.</span> <span class="toc-text">3.1. 线性表的抽象数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">3.2.</span> <span class="toc-text">3.2. 线性表的顺序存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#321%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E5%AE%9A%E4%B9%89"><span class="toc-number">3.2.1.</span> <span class="toc-text">3.2.1. 顺序存储定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#322%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">3.2.2.</span> <span class="toc-text">3.2.2. 顺序存储方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#323%E5%9C%B0%E5%9D%80%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95"><span class="toc-number">3.2.3.</span> <span class="toc-text">3.2.3. 地址计算方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#33%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E7%9A%84%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4"><span class="toc-number">3.3.</span> <span class="toc-text">3.3. 顺序存储结构的插入和删除</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#331%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C"><span class="toc-number">3.3.1.</span> <span class="toc-text">3.3.1. 插入操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#332%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="toc-number">3.3.2.</span> <span class="toc-text">3.3.2. 删除操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#333%E7%BA%BF%E6%80%A7%E8%A1%A8%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">3.3.3.</span> <span class="toc-text">3.3.3. 线性表顺序存储结构的优缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#34%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">3.4.</span> <span class="toc-text">3.4. 线性表的链式存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#341%E7%BA%BF%E6%80%A7%E8%A1%A8%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89"><span class="toc-number">3.4.1.</span> <span class="toc-text">3.4.1. 线性表链式存储结构定义</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#35%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E8%AF%BB%E5%8F%96"><span class="toc-number">3.5.</span> <span class="toc-text">3.5. 单链表的读取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#36%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A5%E4%B8%8E%E5%88%A0%E9%99%A4"><span class="toc-number">3.6.</span> <span class="toc-text">3.6. 单链表的插入与删除</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#361%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A5"><span class="toc-number">3.6.1.</span> <span class="toc-text">3.6.1. 单链表的插入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#362%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%A0%E9%99%A4"><span class="toc-number">3.6.2.</span> <span class="toc-text">3.6.2. 单链表的删除</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#37%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%95%B4%E8%A1%A8%E5%88%9B%E5%BB%BA"><span class="toc-number">3.7.</span> <span class="toc-text">3.7. 单链表的整表创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#38%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%95%B4%E8%A1%A8%E5%88%A0%E9%99%A4"><span class="toc-number">3.8.</span> <span class="toc-text">3.8. 单链表的整表删除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#39%E5%8D%95%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84%E5%92%8C%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">3.9.</span> <span class="toc-text">3.9. 单链表结构和顺序存储结构的优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#310%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8"><span class="toc-number">3.10.</span> <span class="toc-text">3.10. 静态链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3101%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C"><span class="toc-number">3.10.1.</span> <span class="toc-text">3.10.1. 静态链表的插入操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3102%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%A0%E9%99%A4"><span class="toc-number">3.10.2.</span> <span class="toc-text">3.10.2. 静态链表的删除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3103%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">3.10.3.</span> <span class="toc-text">3.10.3. 静态链表优缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#311%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8"><span class="toc-number">3.11.</span> <span class="toc-text">3.11. 循环链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#312%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-number">3.12.</span> <span class="toc-text">3.12. 双向链表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97"><span class="toc-number">4.</span> <span class="toc-text">4. 栈与队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#41%E6%A0%88"><span class="toc-number">4.1.</span> <span class="toc-text">4.1. 栈</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#411%E8%BF%9B%E5%87%BA%E6%A0%88%E5%8F%98%E5%8C%96%E5%BD%A2%E5%BC%8F"><span class="toc-number">4.1.1.</span> <span class="toc-text">4.1.1. 进出栈变化形式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#42%E6%A0%88%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E5%8F%8A%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.2.</span> <span class="toc-text">4.2. 栈的顺序存储结构及实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#421%E6%A0%88%E7%9A%84%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89"><span class="toc-number">4.2.1.</span> <span class="toc-text">4.2.1. 栈的结构定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#422%E8%BF%9B%E6%A0%88%E6%93%8D%E4%BD%9C"><span class="toc-number">4.2.2.</span> <span class="toc-text">4.2.2. 进栈操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#423%E5%87%BA%E6%A0%88%E6%93%8D%E4%BD%9C"><span class="toc-number">4.2.3.</span> <span class="toc-text">4.2.3. 出栈操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#43%E4%B8%A4%E6%A0%88%E5%85%B1%E4%BA%AB%E7%A9%BA%E9%97%B4"><span class="toc-number">4.3.</span> <span class="toc-text">4.3. 两栈共享空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#44%E6%A0%88%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E5%8F%8A%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.4.</span> <span class="toc-text">4.4. 栈的链式存储结构及实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#441%E9%93%BE%E6%A0%88%E7%9A%84%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89"><span class="toc-number">4.4.1.</span> <span class="toc-text">4.4.1. 链栈的结构定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#442%E8%BF%9B%E6%A0%88%E6%93%8D%E4%BD%9C"><span class="toc-number">4.4.2.</span> <span class="toc-text">4.4.2. 进栈操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#443%E5%87%BA%E6%A0%88%E6%93%8D%E4%BD%9C"><span class="toc-number">4.4.3.</span> <span class="toc-text">4.4.3. 出栈操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#444%E9%93%BE%E6%A0%88%E7%9A%84%E6%80%BB%E7%BB%93"><span class="toc-number">4.4.4.</span> <span class="toc-text">4.4.4. 链栈的总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#45%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8%E9%80%92%E5%BD%92"><span class="toc-number">4.5.</span> <span class="toc-text">4.5. 栈的应用 —— 递归</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#451%E9%80%92%E5%BD%92%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">4.5.1.</span> <span class="toc-text">4.5.1. 递归的定义</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#46%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC"><span class="toc-number">4.6.</span> <span class="toc-text">4.6. 栈的应用 —— 四则运算表达式求值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#471%E5%90%8E%E7%BC%80%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E7%A4%BA%E6%B3%95%E5%AE%9A%E4%B9%89"><span class="toc-number">4.6.1.</span> <span class="toc-text">4.7.1. 后缀 (逆波兰) 表示法定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#472%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">4.6.2.</span> <span class="toc-text">4.7.2. 中缀表达式转后缀表达式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#48%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">4.7.</span> <span class="toc-text">4.8. 队列的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#49%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97"><span class="toc-number">4.8.</span> <span class="toc-text">4.9. 循环队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#491%E9%98%9F%E5%88%97%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%9A%84%E4%B8%8D%E8%B6%B3"><span class="toc-number">4.8.1.</span> <span class="toc-text">4.9.1. 队列顺序存储的不足</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#492%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E5%AE%9A%E4%B9%89"><span class="toc-number">4.8.2.</span> <span class="toc-text">4.9.2. 循环队列定义</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#410%E9%98%9F%E5%88%97%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E5%8F%8A%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.9.</span> <span class="toc-text">4.10. 队列的链式存储结构及实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E4%B8%B2"><span class="toc-number">5.</span> <span class="toc-text">5. 串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#51%E4%B8%B2%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.1.</span> <span class="toc-text">5.1. 串的抽象数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#52%E4%B8%B2%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">5.2.</span> <span class="toc-text">5.2. 串的存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#521%E4%B8%B2%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">5.2.1.</span> <span class="toc-text">5.2.1. 串的顺序存储结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#522%E4%B8%B2%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">5.2.2.</span> <span class="toc-text">5.2.2. 串的链式存储结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#53%E6%9C%B4%E7%B4%A0%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95"><span class="toc-number">5.3.</span> <span class="toc-text">5.3. 朴素的模式匹配算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#54kmp%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95"><span class="toc-number">5.4.</span> <span class="toc-text">5.4.KMP 模式匹配算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#541kmp%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86"><span class="toc-number">5.4.1.</span> <span class="toc-text">5.4.1.KMP 模式匹配算法原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#542next%E6%95%B0%E7%BB%84%E5%80%BC%E6%8E%A8%E5%AF%BC"><span class="toc-number">5.4.2.</span> <span class="toc-text">5.4.2.next 数组值推导</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#543kmp%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.4.3.</span> <span class="toc-text">5.4.3.KMP 模式匹配算法实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#55%E5%A0%86%E4%B8%B2"><span class="toc-number">5.5.</span> <span class="toc-text">5.5. 堆串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#56%E5%9D%97%E9%93%BE%E4%B8%B2"><span class="toc-number">5.6.</span> <span class="toc-text">5.6. 块链串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#57%E6%80%BB%E7%BB%93"><span class="toc-number">5.7.</span> <span class="toc-text">5.7. 总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E6%95%B0%E7%BB%84%E4%B8%8E%E5%B9%BF%E4%B9%89%E8%A1%A8"><span class="toc-number">6.</span> <span class="toc-text">6. 数组与广义表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#61%E6%95%B0%E7%BB%84%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E8%BF%90%E7%AE%97"><span class="toc-number">6.1.</span> <span class="toc-text">6.1. 数组的定义与运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#62%E6%95%B0%E7%BB%84%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E4%B8%8E%E5%AE%9E%E7%8E%B0"><span class="toc-number">6.2.</span> <span class="toc-text">6.2. 数组的顺序存储与实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#621%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E5%9C%B0%E5%9D%80%E7%9A%84%E8%AE%A1%E7%AE%97"><span class="toc-number">6.2.1.</span> <span class="toc-text">6.2.1. 一维数组地址的计算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#622%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%9C%B0%E5%9D%80%E8%AE%A1%E7%AE%97"><span class="toc-number">6.2.2.</span> <span class="toc-text">6.2.2. 二维数组的地址计算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#623%E4%B8%89%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%9C%B0%E5%9D%80%E8%AE%A1%E7%AE%97"><span class="toc-number">6.2.3.</span> <span class="toc-text">6.2.3. 三维数组的地址计算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#624n%E7%BB%B4%E6%95%B0%E7%BB%84%E5%9C%B0%E5%9D%80%E8%AE%A1%E7%AE%97"><span class="toc-number">6.2.4.</span> <span class="toc-text">6.2.4.n 维数组地址计算</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#63%E7%89%B9%E6%AE%8A%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8"><span class="toc-number">6.3.</span> <span class="toc-text">6.3. 特殊矩阵的压缩存储</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#631%E8%A7%84%E5%BE%8B%E5%88%86%E5%B8%83%E7%9A%84%E7%89%B9%E6%AE%8A%E7%9F%A9%E9%98%B5"><span class="toc-number">6.3.1.</span> <span class="toc-text">6.3.1. 规律分布的特殊矩阵</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#632%E4%B8%89%E8%A7%92%E7%9F%A9%E9%98%B5"><span class="toc-number">6.3.2.</span> <span class="toc-text">6.3.2. 三角矩阵</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#633%E5%B8%A6%E7%8A%B6%E7%9F%A9%E9%98%B5"><span class="toc-number">6.3.3.</span> <span class="toc-text">6.3.3. 带状矩阵</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#634%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5"><span class="toc-number">6.3.4.</span> <span class="toc-text">6.3.4. 稀疏矩阵</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#64%E5%B9%BF%E4%B9%89%E8%A1%A8"><span class="toc-number">6.4.</span> <span class="toc-text">6.4. 广义表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#641%E5%B9%BF%E4%B9%89%E8%A1%A8%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">6.4.1.</span> <span class="toc-text">6.4.1. 广义表的存储结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#66%E6%80%BB%E7%BB%93"><span class="toc-number">6.5.</span> <span class="toc-text">6.6. 总结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#661%E4%B8%BB%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-number">6.5.1.</span> <span class="toc-text">6.6.1. 主要知识点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E6%A0%91"><span class="toc-number">7.</span> <span class="toc-text">7. 树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#71%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">7.1.</span> <span class="toc-text">7.1. 树的定义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#711%E7%BB%93%E7%82%B9%E5%88%86%E7%B1%BB"><span class="toc-number">7.1.1.</span> <span class="toc-text">7.1.1. 结点分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#712%E7%BB%93%E7%82%B9%E9%97%B4%E5%85%B3%E7%B3%BB"><span class="toc-number">7.1.2.</span> <span class="toc-text">7.1.2. 结点间关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#713%E6%A0%91%E7%9A%84%E5%85%B6%E4%BB%96%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-number">7.1.3.</span> <span class="toc-text">7.1.3. 树的其他相关概念</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#72%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">7.2.</span> <span class="toc-text">7.2. 树的存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#721%E5%8F%8C%E4%BA%B2%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="toc-number">7.2.1.</span> <span class="toc-text">7.2.1. 双亲表示法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#722%E5%AD%A9%E5%AD%90%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="toc-number">7.2.2.</span> <span class="toc-text">7.2.2. 孩子表示法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#723%E5%AD%A9%E5%AD%90%E5%85%84%E5%BC%9F%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="toc-number">7.2.3.</span> <span class="toc-text">7.2.3. 孩子兄弟表示法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#73%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">7.3.</span> <span class="toc-text">7.3. 二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#731%E4%BA%8C%E5%8F%89%E6%A0%91%E7%89%B9%E7%82%B9"><span class="toc-number">7.3.1.</span> <span class="toc-text">7.3.1. 二叉树特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#732%E7%89%B9%E6%AE%8A%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">7.3.2.</span> <span class="toc-text">7.3.2. 特殊二叉树</span></a></li></ol></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Greg yang" data-src="/images/avatar.jpg"><p class="name" itemprop="name">Greg yang</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">5</span> <span class="name">文章</span></a></div></nav><div class="social"><a href="https://github.com/Greg267" title="https:&#x2F;&#x2F;github.com&#x2F;Greg267" class="item github"><i class="ic i-github"></i></a> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9tci15LTIwLTIxLTYx" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;mr-y-20-21-61"><i class="ic i-zhihu"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTYwNjE4NTYxMQ==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;606185611"><i class="ic i-cloud-music"></i></span> <span class="exturl item weibo" data-url="aHR0cHM6Ly93ZWliby5jb20vNzcxNjkwNTc3MC9wcm9maWxlP3RvcG5hdj0xJnd2cj02" title="https:&#x2F;&#x2F;weibo.com&#x2F;7716905770&#x2F;profile?topnav&#x3D;1&amp;wvr&#x3D;6"><i class="ic i-weibo"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>friends</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/Ajax/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/javascipt/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"></div><span><a href="/C%E8%AF%AD%E8%A8%80/" title="C语言">C语言</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/javascipt/" title="JavaScript">JavaScript</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/hello-world/" title="Hello World">Hello World</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/Ajax/" title="Ajax">Ajax</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="数据结构">数据结构</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Greg yang @ Greg yang</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">58k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">52 分钟</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<a href="https://github.com/amehime/hexo-theme-shoka">Shoka</a></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"数据结构/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html>