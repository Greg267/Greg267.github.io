<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" href="https://github.com/Greg267/rss.xml"><link rel="alternate" type="application/atom+xml" href="https://github.com/Greg267/atom.xml"><link rel="alternate" type="application/json" href="https://github.com/Greg267/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><link rel="canonical" href="https://github.com/Greg267/javascipt/"><title>JavaScript | Greg yang =</title><meta name="generator" content="Hexo 6.2.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">JavaScript</h1><div class="meta"><span class="item" title="创建时间：2022-05-12 20:09:50"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2022-05-12T20:09:50+08:00">2022-05-12</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>18k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>16 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Greg yang</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva2.sinaimg.cn/large/008qflI6ly8h25g9pl9l2j308c05jaab.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/008qflI6ly8h25fuse10xj31900u0go8.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/008qflI6ly8h25fy4pwdmj30dw0813zq.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/008qflI6ly8h25g98rrmwj308c04p3yk.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/008qflI6ly8h25g83b2kjj308c05kglo.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/008qflI6ly8h25fuse10xj31900u0go8.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://github.com/Greg267/javascipt/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Greg yang"><meta itemprop="description" content=", "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content=""></span><div class="body md" itemprop="articleBody"><h2 id="1js的引入"><a class="anchor" href="#1js的引入">#</a> &lt;1&gt;.js 的引入</h2><p>基本上同 css 引入，但外部引入时，格式不同，其格式为 &lt;script src=&quot;my.js&quot;&gt; &lt;/script &gt; 其中间不能写任何代码</p><h2 id="2js的输入输出语句"><a class="anchor" href="#2js的输入输出语句">#</a> &lt;2&gt;js 的输入输出语句</h2><p>prompt (''), 浏览器弹出输入框，用户可以输入，取过来的值是字符类型的</p><p>alert (''), 浏览器弹出警示框，输出内容</p><p>console.log ('')，浏览器控制台打印输出信息，用于程序员测试，在网页的控制台中能看到</p><p>想要输出多个变量，在括号里用逗号连接多个变量名即可</p><h2 id="3-变量"><a class="anchor" href="#3-变量">#</a> &lt;3&gt; 变量</h2><p>a. 本质：变量是程序在内存中申请的一块用来存放数据的空间。在使用时分为两大步：1. 声明变量 2. 赋值</p><p>1. 声明变量。格式为 var 变量名；</p><p>2. 赋值。变量名 = 值；</p><p>变量的初始化：声明变量的同时赋值</p><p>一个变量被重新赋值后，它原有的值就会被覆盖，变量值将以最后一次赋的值为准</p><p>同时声明多个变量时，只需要写一个 var，多个变量名之间使用<strong>英文逗号</strong>隔开</p><p><img data-src="/images/JavaScript/js%E4%B9%8B%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99.png" alt="2"></p><p>b.js 的变量数据类型是只有程序在运行过程中，根据等号右边的值来确定的，且 js 是动态语言，变量的数据类型是可以变化的</p><h2 id="4数字类型"><a class="anchor" href="#4数字类型">#</a> &lt;4&gt;. 数字类型</h2><h3 id="a数字型number"><a class="anchor" href="#a数字型number">#</a> a. 数字型 (number)</h3><p>进制类型</p><h3 id="b字符串型string"><a class="anchor" href="#b字符串型string">#</a> b. 字符串型 string</h3><p>其中的文本必须在单引号或者双引号中，如果文本中还要用到引号，则需和包含文本的引号区分开。字符串转义字符都是用 \ 开头，但是这些转义字符都要写在引号里面；</p><p>检测获取字符串的长度 length，用法为在输出字符串时，在变量名后加一个.length</p><p>字符串拼接，输出字符时，多个字符串之间可以使用 + 进行拼接，其拼接方式为字符串 + 任何类型 = 拼接之后的新字符串，其中的字符串也可以是数字类型的，如果两个都是数字类型，则将进行运算，口诀数字相加，字符相连</p><p>字符串拼接加强，可以在输出的字符中间加入变量，使输出的内容可以随变量的值改变而改变，注意的是，别把变量名加在字符串的单引号的中间，否则的话，变量将以变量名的形式输出</p><h3 id="c布尔型"><a class="anchor" href="#c布尔型">#</a> c. 布尔型</h3><p>只有 true 和 false 两种类型。true 代表 1，false 代表 0</p><h3 id="dundefined和null"><a class="anchor" href="#dundefined和null">#</a> d.undefined 和 null</h3><p>如果一个变量未赋值，那么它就是 undefined，称为未定义数据类型，undefined 和数字相加，最后的结果是 NaN (not a number)</p><p>null 和数字相加时就相当于 0，和字符拼接时，输出的就为 null</p><h2 id="5获取变量类型"><a class="anchor" href="#5获取变量类型">#</a> &lt;5&gt;. 获取变量类型</h2><p>在输出时加入 typeof 变量名 ，就可以知道变量的类型，如 console.log (typeof 变量名)</p><h2 id="6数据类型转换"><a class="anchor" href="#6数据类型转换">#</a> &lt;6&gt;. 数据类型转换</h2><p>通俗的说，就是把一种数据类型的变量转换成另外一种数据类型</p><h3 id="a转换为字符串"><a class="anchor" href="#a转换为字符串">#</a> a. 转换为字符串</h3><p>把数字类型转换为字符串类型.</p><p>例如 var num=18； var str=num.toString ();</p><p>再例如 console.log (String (num));</p><p>再例如 console.log (num+''); 最后一种也叫隐式转换</p><h3 id="b转换为数字型"><a class="anchor" href="#b转换为数字型">#</a> b. 转换为数字型</h3><p>把其他类型转换为数字类型。</p><p>例如，var age=prompt ();console.log (parseInt (age)). 得到是整数，并且会把数据的单位去掉；</p><p>console.log (parseFloat (变量))，可以得到小数；</p><p>console.log(Number(str));</p><p>利用算数运算 + - * / 如 console.log ('12'-0);</p><h3 id="c转换为布尔型"><a class="anchor" href="#c转换为布尔型">#</a> c. 转换为布尔型</h3><p>代表空 否定的值会被转换为 false，如 ''0 NaN null undefined, 所以转换的格式为 console.log (Boolean (0)), 就是一个 false 值；如果其他的值的话就是 true</p><h2 id="7算数运算符"><a class="anchor" href="#7算数运算符">#</a> &lt;7&gt;. 算数运算符</h2><h3 id="a运算符"><a class="anchor" href="#a运算符">#</a> a. 运算符</h3><p>就是 + - * /, 还有 %，就是取余的作用</p><h3 id="b表达式和返回值"><a class="anchor" href="#b表达式和返回值">#</a> b. 表达式和返回值</h3><p>表达式就是由数字，运算符，变量等组成的式子，采用右赋左的形式，返回值就是表达式运算后得到的值</p><h3 id="c递增和递减运算符"><a class="anchor" href="#c递增和递减运算符">#</a> c. 递增和递减运算符</h3><p>可以在变量前或后加 ++ 或 --，表示自增 1 或自减 1 ，称为前置递增 (递减) 运算符或后置递增 (递减) 运算符，且递增 (递减) 只能和变量配合使用，前置运算符先加 1，后返回值，后置运算符先返回原值，后自加 1</p><h2 id="8比较运算符"><a class="anchor" href="#8比较运算符">#</a> &lt;8&gt;. 比较运算符</h2><p>判断表达式是否成立，判断后返回布尔值，且判断式里会自动转换数据类型，相等用 ==，完全相等用 ===，前者只要求值相等，后者就必须要求值和数据类型完全一致才能返回 true</p><h2 id="9逻辑运算符"><a class="anchor" href="#9逻辑运算符">#</a> &lt;9&gt;. 逻辑运算符</h2><p>逻辑运算符是用来进行布尔值运算的运算符，其返回值也是布尔值。后面开发中经常用于多个条件的判断。&amp;&amp; 相当于与 and，|| 相当于或 or。！相当于非 not。逻辑与 &amp;&amp; 两侧都为 true，结果才是 true 只要有一侧为 false，结果就为 false。逻辑或 || 两侧都为假，结果才是假，一侧为真，结果为真</p><h3 id="a短路运算"><a class="anchor" href="#a短路运算">#</a> a. 短路运算</h3><p>与 &amp;&amp; 如果表达式 1 结果为真，则返回表达式二，如果表达式 1 结果为假，则返回表达式一，例如 console.log (123&amp;&amp;456), 返回的是 456</p><p>或 || 如果表达式一的值为真，则返回表达式一，如果表达式一的结果为假，则返回表达式二</p><h2 id="10赋值运算符"><a class="anchor" href="#10赋值运算符">#</a> &lt;10&gt;. 赋值运算符</h2><p>用来吧数据赋值给变量的运算符</p><p>= 直接赋值，+=，-= 加减一个数后再赋值</p><p>*= /=、%= 乘 除 取模一个数后再赋值</p><h4 id="运算符优先级"><a class="anchor" href="#运算符优先级">#</a> 运算符优先级</h4><p><img data-src="/images/JavaScript/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7.png" alt="2"></p><p>一元运算符里的逻辑非优先级很高，逻辑与比逻辑或优先级高</p><h2 id="11流程控制"><a class="anchor" href="#11流程控制">#</a> &lt;11&gt;. 流程控制</h2><p>流程控制就是来控制我们的代码按照什么结构顺序来执行</p><h3 id="a分支结构"><a class="anchor" href="#a分支结构">#</a> a. 分支结构</h3><p>由上到下执行代码的过程中，根据不同的条件，执行不同的路径代码 (执行代码多选一的过程)，从而得到不同的结果</p><h4 id="1if语句"><a class="anchor" href="#1if语句">#</a> 1.if 语句</h4><p>语法结构</p><p 执行语句二="">if (条件表达式) {执行语句一} else</p><p>先判断括号里的条件表达式是否为真，为真就执行大括号里的语句，如果为假，则执行大括号外的语句；语句一和语句二最终只能有一个执行；else 后不接（），直接接大括号</p><h5 id="多分支语句"><a class="anchor" href="#多分支语句">#</a> 多分支语句</h5><p>利用 if else if</p><p 以上都不满足后最终执行的语句="">if (条件表达式 1){ 语句一 } else if (条件表达式二){ 语句二 } else if (条件表达式三){ 语句三 }...else</p><p>注意点：1. 多分支语句还是多选一 最后只能有一个语句被执行 2.else if 里的条件可以无论多个 3.else if 中间有个空格</p><h4 id="2三元表达式"><a class="anchor" href="#2三元表达式">#</a> 2. 三元表达式</h4><p>格式为 条件表达式？ 表达式 1：表达式 2；如果条件表达式结果为真，则返回表达式 1 的值，如果条件表达式的结果为假，则返回表达式二的值，既然要返回值，那么就要把表达式赋给变量，所以可以将格式写成 var 变量名 = 条件表达式？ 表达式 1：表达式 2，最后输出变量即可</p><h4 id="3switch语句"><a class="anchor" href="#3switch语句">#</a> 3.switch 语句</h4><p>基于不同条件执行不同代码，针对一系列特定值的选项时，可以使用这个</p><p case="" 值1:="" 执行语句一;="" break;="" case="" 值2:="" 执行语句二;="" break;="" css-module="." default:都没有匹配上，执行最后的语句;="">格式为 switch (表达式)</p><p>注意事项：1. 表达式里我们经常写成变量；2. 表达式的值要和 case 里的值数据和类型都一致才能匹配成功</p><h4 id="3if-else-if和switch的区别"><a class="anchor" href="#3if-else-if和switch的区别">#</a> 3.if else if 和 switch 的区别</h4><p>一般情况下，两者可以互换</p><p>swich...case 语句通常处理 case 为比较确定值的情况，而 if else 语句更加灵活，常用于范围判断</p><p>switch 语句进行条件判断后直接执行到程序的条件语句，效率更高，而 if else 语句有几种条件，就得判断多少次</p><p>当分支比较少时，if else 语句的执行效率比 switch 语句高，当分支比较多时，switch 语句的执行效率比较高，而且结构更清晰</p><h3 id="b循环结构"><a class="anchor" href="#b循环结构">#</a> b. 循环结构</h3><p>可以重复执行某些语句或代码，一组被重复执行的语句被称为循环体，能否继续重复执行，取决于循环的终止条件</p><h4 id="1for"><a class="anchor" href="#1for">#</a> 1.for</h4><p>for 重复执行某些代码，通常跟计数有关系</p><p>结构如下 for (初始化变量；条件表达式；操作表达式){循环体}，初始化变量就是用 var 声明的一个普通变量，通常作为计数器使用；条件表达式就是用来决定每一次循环是否都继续执行，就是终止的条件；操作表达式是每次循环最后执行的代码经常用于我们计数器变量进行更新 (递增或递减)，<strong>判断条件表达式后，若符合，则先执行循环体，然后再进行操作表达式；若不符合，直接终止循环</strong></p><p>断点调试</p><p><img data-src="/images/JavaScript/%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95.png" alt="2"></p><h5 id="for-循环执行不同的代码"><a class="anchor" href="#for-循环执行不同的代码">#</a> for 循环执行不同的代码</h5><p>因为有计数器变量 i 的存在 ，所以可以执行不同的代码，再嵌套 if else</p><h5 id="for-在一行中连续打印字符"><a class="anchor" href="#for-在一行中连续打印字符">#</a> for 在一行中连续打印字符</h5><p>先给变量赋一个字符值，然后在循环中连续追加字符，比如，var str='',...,str=str+' 字符'</p><h4 id="2双重for循环"><a class="anchor" href="#2双重for循环">#</a> 2. 双重 for 循环</h4><p>也叫循环嵌套，指子在一个循环语句中再定义一个循环语句的语法结构，例如在 for 循环语句中，可以再嵌套一个 for 循环，这样的 for 循环语句我们称之为双重 for 循环，格式如下 for (外层的初始化变量；外层的条件表达式；外层的操作表达式){for (里层的初始化变量；里层的条件表达式；里层的操作表达式){执行语句；}}</p><p>外层循环一次，里面的循环全部执行</p><h4 id="3while语句"><a class="anchor" href="#3while语句">#</a> 3.while 语句</h4><p 循环语句="">结构如下，while (条件表达式)</p><p>条件表达式结果为真，执行循环体，条件表达式结果为假，退出 循环</p><h5 id="4do"><a class="anchor" href="#4do">#</a> <span class="exturl" data-url="aHR0cDovLzQuZG8=">4.do</span> while 循环</h5><p 条件表达式="">格式为 do {循环体} while</p><p>do while 先执行一次循环体 在判断条件 如果条件表达式结果为真，则继续执行代码，否则退出循环，所以 do while 至少执行一次</p><h3 id="循环小结"><a class="anchor" href="#循环小结">#</a> 循环小结</h3><p>循环结构 for, while, do while, 三个循环多数情况下可以相互替代使用，如果用来计次数，跟数字相关的，三者使用基本相同，但我们更喜欢用 for；</p><p>和 do while 可以做跟复杂的判断条件，比 for 更灵活一些；</p><p>while 和 do while 有区别，前者先判断后执行，后者先执行一次，然后再判断执行</p><h5 id="5continue和break"><a class="anchor" href="#5continue和break">#</a> 5.continue 和 break</h5><p>continue 关键字用于立即跳出本次循环，继续下一次循环 (本次循环体中 continue 之后的代码就会少执行一次，比如循环语句中有 if 语句，if 语句中有 continue，当 if 判断为真，则执行 continue，if 后面的，也就是 for 的循环体就不会执行，直接跳到下一次循环)</p><p>break 关键字用于立即跳出整个循环 (循环结束)</p><h2 id="12数组"><a class="anchor" href="#12数组">#</a> &lt;12&gt;. 数组</h2><p>数组 (Array) 是指一组数据的集合，其中的每个数据被称作元素，在数组中可以存放任意类型的元素，数组是一种将一组数据存储在单个变量名下的优雅方式</p><p>利用 new 创建数组 var arr = new Array ();</p><p>利用数组字面量创建数组 var arr = []; 数组内可以放任意类型的数据；数组内的数据一定要用逗号 (,) 分隔开</p><h3 id="1数组的索引"><a class="anchor" href="#1数组的索引">#</a> 1. 数组的索引</h3><p>索引 (下标)：用来访问数组元素的序号 (<strong>数组下标从 0 开始</strong>)</p><p>访问 (获取得到) 数组元素 格式 数组名 [索引号]</p><h3 id="2遍历数组"><a class="anchor" href="#2遍历数组">#</a> 2. 遍历数组</h3><p>是指将数组的元素从头到尾访问一次，可以利用 for 循环，将数组里面的元素全部输出</p><h3 id="数组长度"><a class="anchor" href="#数组长度">#</a> 数组长度</h3><p>数组长度可以用 arr.length 来测量；数组的长度是元素个数，不要跟索引号混淆；arr.length 动态监测数组元素的个数</p><h3 id="3数组新增元素"><a class="anchor" href="#3数组新增元素">#</a> 3. 数组新增元素</h3><p>通过修改 length 长度新增数组元素，新增的元素是 undefined</p><p>通过修改数组索引新增数组元素，比如一个数组在有三个元素，我们可以加上一个 arr [3] = ' 变量名 '; 来向数组追加第四个元素；如果 arr 后的括号里是已有元素的索引号，那么 arr 后的变量将替换原来的变量，但注意不要直接给数组名赋值，否则里面的数组元素都没有了</p><p>筛选数组方法 1：通过 for 循环，再通过一个新的变量来将筛选出来的元素按顺序排入新数组中；方法二：将上个方法的变量换成新数组的长度 (newarr.length)，效果一样</p><h3 id="4数组排列"><a class="anchor" href="#4数组排列">#</a> 4. 数组排列</h3><p>将原数组按一定的顺序进行排列</p><p>将要排列的数组分为两部分，一部分是数组里的元素一共要比较几次，比如五个元素就要进行四次的单个元素的大比较，一部分是每个元素要和其他元素交换几次，</p><h2 id="13函数"><a class="anchor" href="#13函数">#</a> &lt;13&gt;. 函数</h2><p>函数就是封装了一段可以被重复调用执行的代码块。通过此代码块可以实现大量代码的重复使用。</p><h3 id="1函数的声明"><a class="anchor" href="#1函数的声明">#</a> 1. 函数的声明</h3><p>格式如下：function 函数名 (){}</p><p>function 声明函数的关键字，全部小写</p><p>函数是做某件事，函数名一般是动词</p><p>函数不调用，自己不执行</p><h3 id="2函数的调用"><a class="anchor" href="#2函数的调用">#</a> 2. 函数的调用</h3><p>格式如下 函数名 () 调用函数的时候千万不要忘记加小括号</p><h3 id="3函数的封装"><a class="anchor" href="#3函数的封装">#</a> 3. 函数的封装</h3><p>函数的封装是把一个或者多个功能通过函数的方式封装起来，对外只提供一个简单的函数接口，格式为 function 函数名 () {}, 后面要调用直接用以下格式 函数名 ();</p><h3 id="4函数的参数"><a class="anchor" href="#4函数的参数">#</a> 4. 函数的参数</h3><p>上述函数名后的括号里的元素即为参数，function 后面的叫形参 (形式上的参数)，当时并不知道是什么，调用时的参数叫做实参 (实际上的参数)，实参再传递给形参，函数的参数可以有，也可以没有，个数不限。</p><p>参数的作用：在函数内部某些值不确定固定，我们可以通过参数在调用函数时传递不同的值进去</p><p>多个参数之间用逗号 (,) 隔开</p><p>形参可以看作是不声明的变量</p><h4 id="函数形参和实参个数匹配问题"><a class="anchor" href="#函数形参和实参个数匹配问题">#</a> 函数形参和实参个数匹配问题</h4><p>如果实参的个数和形参的个数一致，则正常输出结果</p><p>如果实参的个数多于新参的个数，会取到形参的个数，多的实参将不管</p><p>如果实参的个数少于形参的个数，则会输出 NaN，因为形参可以看作一个未赋值的变量，则将其用于运算中，它就会显示 Undefined, 一个数加上 undefined，就是 NaN</p><h3 id="5函数的返回值"><a class="anchor" href="#5函数的返回值">#</a> 5. 函数的返回值</h3><p css-module=".." return="" 需要返回的结果="">运用 return 语句，格式如下 function 函数名 ()</p><p>函数的功能只是实现某种功能，最终的结果需要返回给函数的调用者</p><p>只要函数遇到 return 就把后面的结果返回给函数的调用者，在实际开发里，我们经常用一个变量来接受函数的返回值，使用更简单</p><p>return 会终止函数，也就是位于同一级的在 return 后面的语句不会被执行</p><p>return 只会输出一个结果，以最后一个值为准，如果要输出多个结果，则可结合数组来输出多个值，但返回的值是数组</p><p>我们的函数如果有 return，则返回的是 return 后面的值，如果函数没有 return，则返回 undefined</p><h4 id="breakcontinuereturn的区别"><a class="anchor" href="#breakcontinuereturn的区别">#</a> break，continue，return 的区别</h4><p>![2](/images/JavaScript/break continue return 的区别.png)</p><h3 id="6arguments的使用"><a class="anchor" href="#6arguments的使用">#</a> 6.arguments 的使用</h3><p>arguments 实际上它是当前函数的一个内置对象，所有的函数都内置了一个 arguments 对象，对 arguments 对象中存储了传递的所有实参，arguments 展示形式是一个伪数组，因此可以进行遍历</p><p>伪数组的特征：1. 具有 length 属性；2. 按索引方式储存数据；3. 不具有数组的 push，pop 等方法</p><h3 id="7函数的两种声明方式"><a class="anchor" href="#7函数的两种声明方式">#</a> 7. 函数的两种声明方式</h3><p>利用函数关键字自定义函数 (命名函数)，如 getMax,getSum</p><p>函数表达式（匿名函数），格式如下 var 变量名 = function () {}, 后面调用格式为 变量名 (); 注意，是变量名，不是函数名；函数表达式声明方式跟变量差不多，只不过变量里的是值，而函数表达式里面存的是函数；函数表达式也可以传递变量</p><h2 id="14javascript作用域"><a class="anchor" href="#14javascript作用域">#</a> &lt;14&gt;.JavaScript 作用域</h2><h3 id="1作用域"><a class="anchor" href="#1作用域">#</a> 1. 作用域</h3><p>JavaScript 作用域就是代码名字 (变量) 在某个范围内起作用和效果，目的是为了提高程序的可靠性，更重要的是减少命名冲突，不在同一个作用域下，相同的两个变量名不会起冲突</p><h3 id="两种作用域全局作用域-局部作用域"><a class="anchor" href="#两种作用域全局作用域-局部作用域">#</a> 两种作用域：全局作用域、局部作用域</h3><p>全局作用域：整个 script 标签或者一个单独的 JS 文件</p><p>局部作用域：在函数内部就是局部作用域，也就是说，这个代码的名字只在函数内部起效果和作用</p><h3 id="2变量作用域"><a class="anchor" href="#2变量作用域">#</a> 2. 变量作用域</h3><p>全局变量：在全局作用域中用 var 声明的变量，<strong>在函数内部没有声明直接赋值的变量</strong></p><p>局部变量：在局部作用域中声明的变量，或者在函数内部的变量，或者函数的形参也可以看作局部变量</p><h4 id="作用效率"><a class="anchor" href="#作用效率">#</a> 作用效率</h4><p>全局变量只有在浏览器关闭的时候会销毁，比较占内部内存资源；局部变量当我们程序执行完毕就会销毁，比较节约内存资源</p><h4 id="js没有块级作用域es6的时候才有"><a class="anchor" href="#js没有块级作用域es6的时候才有">#</a> js 没有块级作用域 es6 的时候才有</h4><h3 id="3作用域链"><a class="anchor" href="#3作用域链">#</a> 3. 作用域链</h3><p>内部函数可以访问外部函数里的变量，采用链式查找的方式，决定取哪个变量，一层一层往外找距离最近的变量</p><h2 id="15javascript预解析"><a class="anchor" href="#15javascript预解析">#</a> &lt;15&gt;.JavaScript 预解析</h2><h3 id="1js引擎运行js分为两步预解析-代码执行"><a class="anchor" href="#1js引擎运行js分为两步预解析-代码执行">#</a> 1.js 引擎运行 js 分为两步：预解析 代码执行</h3><p>(1). 预解析：js 引擎会把 js 里面所有的 var 还有 function 提升到当前作用域的最前面</p><p>(2). 代码执行：按照代码书写的顺序从上往下执行</p><h3 id="2预解析分为变量预解析变量提升和函数预解析函数提升"><a class="anchor" href="#2预解析分为变量预解析变量提升和函数预解析函数提升">#</a> 2. 预解析分为变量预解析 (变量提升) 和函数预解析 (函数提升)</h3><p>(1) 变量提升：就是把所有的变量声明提升到当前的作用域的最前面，不提升赋值操作</p><p>函数提升：就是把所有的函数声明提升到作用域的最前面，不调用函数，所以函数表达式调用必须写在函数表达式的下面</p><h2 id="16javascript对象"><a class="anchor" href="#16javascript对象">#</a> &lt;16&gt;.JavaScript 对象</h2><h3 id="1对象"><a class="anchor" href="#1对象">#</a> 1. 对象</h3><p>对象是一组无序的相关属性和方法的集合，所有的事物都是对象</p><p>属性：事物的特征，在对象中有属性来表示 (常用名词)</p><p>方法：事物的行为，在对象中用方法来表示 (常用动词)</p><p>好处：使对象表达结构更清晰，更强大</p><h3 id="2创建对象"><a class="anchor" href="#2创建对象">#</a> 2. 创建对象</h3><p>1. 利用字面量创建对象</p><p>2. 利用 new Object 创建对象</p><p>3. 利用构造函数创建对象</p><h4 id="字面量创建对象"><a class="anchor" href="#字面量创建对象">#</a> 字面量创建对象</h4><p>格式为 var obj = {属性名：值， 属性名：' 字符串 '， 方法名：function ()</p><h4 id="使用对象"><a class="anchor" href="#使用对象">#</a> 使用对象</h4><h5 id="调用对象的属性"><a class="anchor" href="#调用对象的属性">#</a> 调用对象的属性</h5><p>调用对象的属性，我们采取对象名。属性名在，这个。我们理解为 的</p><p>还有一种调用方法 对象名 [' 属性名 ']</p><h5 id="调用对象的方法"><a class="anchor" href="#调用对象的方法">#</a> 调用对象的方法</h5><p>对象名。方法名 ()</p><h3 id="3变量-属性-函数-方法的区别"><a class="anchor" href="#3变量-属性-函数-方法的区别">#</a> 3. 变量、属性、函数、方法的区别</h3><p>变量和属性的相同点：他们都是用来储存数据的</p><p>不同点：变量单独声明并赋值，使用的时候直接写变量名，单独存在；属性：在对象里面的不需要声明的，使用的时候必须是对象。属性</p><p>函数和方法的相同点：都是实现某种功能，做某件事</p><p>函数使单独声明并且调用的 函数名 () 单独存在</p><p>方法：在对象里面调用的时候 对象。方法 ()</p><h4 id="利用new-object创建对象"><a class="anchor" href="#利用new-object创建对象">#</a> 利用 new Object 创建对象</h4><p>格式为 var obj = new Object (); 然后通过 obj. 属性名 = 值；的方法来给对象追加属性；通过 obj. 方法名 = function (){} 的方法来给对象追加方法</p><h4 id="利用构造函数创建对象"><a class="anchor" href="#利用构造函数创建对象">#</a> 利用构造函数创建对象</h4><p>某些对象大部分的属性和方法相同，只有一小部分不同，所有我们可以利用函数将相同的部分重复，我们就把这个函数称为构造函数</p><p>格式为 function 构造函数名 (){ this. 属性 = 值； this. 方法 = function (){} } new 构造函数名 ();</p><p>注意：1. 构造函数名字首字母要大写；2. 构造函数不需要 return 就可以返回结果；3. 我们调用构造函数必须使用 new；4. 我们只要 new Star () 调用函数就创建一个对象；5. 我们的属性和方法前面必须添加 this</p><p>例子：function Star (name,age,sex) { <span class="exturl" data-url="aHR0cDovL3RoaXMubmFtZQ==">this.name</span> (变量)=name (形参); this.age (变量)=age (形参); this.sex (变量)=sex (形参); } new Star ('ldh',18,' 男 ');</p><p>函数里只是一些相同的变量，变量的值还需要后面调用时输入的实参</p><h4 id="new关键字的执行过程"><a class="anchor" href="#new关键字的执行过程">#</a> new 关键字的执行过程</h4><p>1.new 构造函数可以在内存中创建了一个空的对象；2.this 就会指向刚才创建的空对象；3. 执行构造函数里的代码，给这个空对象添加属性和方法；4. 返回这个对象</p><h4 id="遍历对象"><a class="anchor" href="#遍历对象">#</a> 遍历对象</h4><p>利用 for in 循环格式如下 for (变量 in 对象)，其中的变量可以是任何变量，但习惯写 k。变量得到的是属性名，要想得到值，则该对象名 [k]</p><h2 id="17javascript内置对象"><a class="anchor" href="#17javascript内置对象">#</a> &lt;17&gt;.JavaScript 内置对象</h2><p>内置对象就是指 js 语言自带的一些对象，这些对象供开发者使用，并提供了一些常用的或是最基本的而必要的功能 (属性和方法)</p><h3 id="1math对象"><a class="anchor" href="#1math对象">#</a> 1.Math 对象</h3><p>不是一个构造函数，所以我们不需要 new 来调用，而是直接使用里面的属性和方法即可。具体的属性和方法有很多，可在 MDN 里面查询</p><h3 id="2date对象"><a class="anchor" href="#2date对象">#</a> 2.Date 对象</h3><p>Date 是个构造函数，必须使用 new 来调用我们创建的日期对象</p><p>使用 Date，如果没有参数，则返回当前系统的时间，格式为 var 变量名 = new Date ();</p><p>参数常用的写法，数字型 2021，10，05，或者是字符串型 '2021-10-5 22：22：22'</p><h4 id="获取毫秒数"><a class="anchor" href="#获取毫秒数">#</a> 获取毫秒数</h4><p><img data-src="/images/JavaScript/%E8%8E%B7%E5%8F%96%E6%AF%AB%E7%A7%92%E6%95%B0.png" alt="2"></p><h4 id="倒计时"><a class="anchor" href="#倒计时">#</a> 倒计时</h4><p>先计算规定时间和现在时间的差的总毫秒数，再利用以下公式转化为天 小时 分钟 秒</p><p><img data-src="/images/JavaScript/%E8%AE%A1%E7%AE%97%E6%97%B6%E9%97%B4%E5%85%AC%E5%BC%8F.png" alt="2"></p><p>然后再用以下代码</p><p><img data-src="/images/JavaScript/%E5%80%92%E8%AE%A1%E6%97%B6%E4%BB%A3%E7%A0%81.png" alt="2"></p><h3 id="3数组对象"><a class="anchor" href="#3数组对象">#</a> 3. 数组对象</h3><h4 id="检测是否为数组"><a class="anchor" href="#检测是否为数组">#</a> 检测是否为数组</h4><p>1.instanceof 运算符，它可以用来检测是否为数组，若为则返回 true，若不是则返回 false</p><p>2.Array.isArray (参数)，若为则返回 true，若不是则返回 false</p><h4 id="添加或删除数组元素"><a class="anchor" href="#添加或删除数组元素">#</a> 添加或删除数组元素</h4><p>1.push () 在数组末尾添加一个或多个元素，参数直接写数组元素就可以了，push 完毕之后，如输出 console.log (arr.push ()) 返回的结果是新数组的长度</p><p>2.unshift 在数组开头添加一个或多个数组元素，参数直接写数组元素就可以了，unshift 完毕之后，如输出 console.log (arr.unshift ()) 返回的结果是新数组的长度</p><p>3.pop () 它可以删除数组最后一个元素，一次只能删除一个元素。不用写参数，直接删除最后一个元素，pop 完毕之后，如输出 console.log (arr.pop ())，返回的结果是删除的那个元素</p><p>4.shift () 删除数组的第一个元素，其他如上</p><h4 id="4颠倒数组"><a class="anchor" href="#4颠倒数组">#</a> 4. 颠倒数组</h4><p>直接用数组名.reverse</p><h4 id="5数组冒泡排序"><a class="anchor" href="#5数组冒泡排序">#</a> 5. 数组冒泡排序</h4><p>直接用数组名.sort，但是不能用于双位数，要用于双位数，则需在 sort 后面加上 (function (a,b){return a-b;})(这是升序排列，如果想要降序排列，则 return b-a;)</p><h4 id="6获取数组元素索引"><a class="anchor" href="#6获取数组元素索引">#</a> 6. 获取数组元素索引</h4><p>用 indexOf ()，括号里加想要知道序列号的元素，如果有多个相同的元素，只返回第一个元素的索引号，如果数组里没有该元素，则返回 - 1</p><h4 id="数组去重案例"><a class="anchor" href="#数组去重案例">#</a> 数组去重案例</h4><p>核心算法就是遍历旧数组，再将旧数组的元素拿去和新数组里的元素比较，如果没有则存入新数组，如果有则不存入，代码为</p><p><img data-src="/images/JavaScript/%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E6%A1%88%E4%BE%8B.png" alt="2"></p><h4 id="7数组转换为字符串"><a class="anchor" href="#7数组转换为字符串">#</a> 7. 数组转换为字符串</h4><p>1. 直接利用 toString (数组名)，将数组转换为字符</p><p>2. 用 join (), 括号里可添加数组元素转换为字符后，元素之间的符号，但符号要加括号，如 join ('-'),join ('&amp;')</p><h4 id="8基本包装类型"><a class="anchor" href="#8基本包装类型">#</a> 8. 基本包装类型</h4><p>就是把基本数据类型包装成了复杂数据类型，这样基本数据类型就有了属性和方法分为三步：1. 把简单数据类型转化为复杂数据类型；2. 将复杂数据类型赋给一个临时变量；3. 待临时变量运用后，删除临时变量</p><h4 id="9字符串的不可变"><a class="anchor" href="#9字符串的不可变">#</a> 9. 字符串的不可变</h4><p>指的是里面的值不可变，虽然看上去可以改变内容，但其实是地址变了，内存中开辟了一个新的内存空间，原来的并没有删除</p><h4 id="10根据字符返回位置"><a class="anchor" href="#10根据字符返回位置">#</a> 10. 根据字符返回位置</h4><p>字符串对象可以根据字符返回位置，str.indexOf (' 要查找的字符 '，[起始的位置])，相当于把字符串当作一个数组来处理，返回的是从查找位置开始第一个要查找的字符所对应的索引号，如果不写起始位置默认为第一个，lastOf 也是一样的用法，只是从后面往前查找</p><h4 id="10根据位置返回字符"><a class="anchor" href="#10根据位置返回字符">#</a> 10. 根据位置返回字符</h4><p>1.charAt (index)，返回指定位置的字符 (index 字符串的索引号)，格式为 str.charAt (0)</p><p>2.charCodeAt (index)，返回指定位置处字符的 ASCⅡ 码，格式为 str.charCodeAt (0), 目的：用于判断用户按下了那个键</p><p>str [index] 获取指定位置处字符，格式为 str [0]</p><h3 id="案例统计出现次数最多的字符"><a class="anchor" href="#案例统计出现次数最多的字符">#</a> 案例：统计出现次数最多的字符</h3><p>首先我们要得到字符串里有哪些字符和它们相应的出现次数，这时其实数组和对象都能用，但对象可以把字符和次数匹配，所以我们选择对象；</p><p>我们可以通过对象名 [' 属性名 '] 来判断对象中是否含有该属性，若存在，则返回 true，不存在则返回 undefined</p><p>那我们就可以通过循环，依次来读入字符串的字符，第一次出现就赋值为 1，再次出现就自增，就可以得到一个对象里面存储着字符和对应出现的次数</p><p>利用 for in 循环来比较次数的大小，并把最大的次数对应的属性名赋给一个变量来输出</p><p>代码如下</p><p><img data-src="/images/JavaScript/%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E6%9C%80%E5%A4%9A.png" alt="2"></p><h4 id="11字符串操作方法"><a class="anchor" href="#11字符串操作方法">#</a> 11. 字符串操作方法</h4><p><img data-src="/images/JavaScript/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95.png" alt="2"></p><p>其他方法：1. 替换字符 replace (' 被替换的字符 ',' 替换的字符 ')，只会替换第一个字符：2. 字符转换为数组 split (&quot;分隔符&quot;)，把字符串转换成数组，括号里的分隔符指的是字符串里字符之间的符号</p><h2 id="18javascrip简单类型与复杂类型"><a class="anchor" href="#18javascrip简单类型与复杂类型">#</a> 18.JavaScrip 简单类型与复杂类型</h2><p><img data-src="/images/JavaScript/%E7%AE%80%E5%8D%95%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%A4%8D%E6%9D%82%E7%B1%BB%E5%9E%8B.png" alt="2"></p><p>堆和栈：系统分配的两个存储空间</p><p>栈一般存储简单数据类型，在栈里开辟一个空间，存放简单数据的值。堆一般存储复杂数据类型，复杂数据类型在栈里存放地址 (指向堆)，在堆里存放数据</p><p>简单类型传参：将实参的值复制了一份给形参，形参在函数中改变不会影响实参</p><p>复杂类型传参：将实参的地址复制给了形参，形参改变会导致实参改变</p><h2 id="19web"><a class="anchor" href="#19web">#</a> <span class="exturl" data-url="aHR0cDovLzE5LldlYg==">19.Web</span> APIs</h2><h3 id="191web"><a class="anchor" href="#191web">#</a> <span class="exturl" data-url="aHR0cDovLzE5LjEuV2Vi">19.1.Web</span> APIs 和 JS 基础关联性</h3><p><img data-src="/images/JavaScript/js%E7%9A%84%E7%BB%84%E6%88%90.png" alt="2"></p><h3 id="192api和webapi"><a class="anchor" href="#192api和webapi">#</a> 19.2.API 和 WebAPI</h3><p>API 是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节，简单的说，API 是给程序员提供的一种工具，以便能更轻松的实现想要完成的功能</p><p>Web API 是浏览器功能和页面元素的 API (BOM 和 DOM)</p><h3 id="193dom"><a class="anchor" href="#193dom">#</a> 19.3.DOM</h3><p><img data-src="/images/JavaScript/DOM%E6%A0%91.png" alt="2"></p><h4 id="1931获取页面元素"><a class="anchor" href="#1931获取页面元素">#</a> 19.3.1. 获取页面元素</h4><p>根据 ID 获取：getElementById (),() 里接 'id 名'</p><p>根据标签名获取：使用 getElementsByTagName (),() 里接 ' 标签名 '，获取来的元素对象的集合以伪数组的形式存储，获取得到的父元素不能直接拿来获取子元素，因为得到的父元素是数组，要用要指明是数组中的第几个</p><p>根据类名获取元素：使用 getElementByClassName (' 类名 ')，返回拥有该类名的所有元素</p><p>querySelector (), 返回指定选择器的第一个元素对象 ('. 类名 ') 或 ('#id 名 ')</p><p>querySelectorAll (), 返回指定选择器的所有元素</p><p>获取特殊元素 (body html), 获取 body 元素 doucument.body; 获取 html 元素：doucument.doucumentElement</p><h4 id="1932事件基础"><a class="anchor" href="#1932事件基础">#</a> 19.3.2. 事件基础</h4><p>事件是由三部分组成 事件源 事件类型 事件处理程序</p><p>事件源：事件被触发的对象，也就是谁被触发了</p><p>事件类型：如何触发，触发的方式，如鼠标点击，鼠标经过等等</p><p>事件处理程序：通过一个函数赋值的方式来完成</p><h4 id="1933操作元素"><a class="anchor" href="#1933操作元素">#</a> 19.3.3. 操作元素</h4><p>改变元素内容：innerText 和 innerHTML 前者会去除掉 html 标签，同时空格和换行也会去掉，后者包括 html 标签，同时保留空格和换行</p><p>修改元素属性：采用 变量名。属性 的方法来进行修改</p><p>表单元素的属性操作：如果想修改表单里的内容，要用 value 而不是 innerText 和 innerHTML</p><p>修改样式属性，如果修改元素少，直接使用 变量名.style. 要修改的属性 如果要修改的属性多，可采用 变量名.className 来换个类名</p><h4 id="1934自定义属性"><a class="anchor" href="#1934自定义属性">#</a> 19.3.4. 自定义属性</h4><p>获取属性：一般方法是 element. 属性 的方法：还有一种是 element.getAttribute (' 属性 ')；还有一种是 element.dataset. 设置的属性名 第一个是获取内置属性值，第二个主要获得自定义的属性 (标准)，也就是我们程序员自定义的属性 (我们为了使用方便自己创造的一些属性)，第三个用来获取自定义属性，如果后不接属性名，则得到的是该元素所有自定义属性的一个数组</p><p>设置自定义属性：一般方法 element. 属性 =' 值 ' 承接上文的另一种方法 element.setAttribute (' 属性 '，' 值 ')，如果要用第二种方法更改类名时，修改的属性是 class 而不是 classname</p><p>移除属性：element.removeAttribute (' 属性 ')</p><p>当我们要设置自定义属性时，属性的名字应该以 data 开头，这是一个标准</p><p><img data-src="/images/JavaScript/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7%E6%93%8D%E4%BD%9C.png" alt="2"></p><h4 id="1935一些应用实例"><a class="anchor" href="#1935一些应用实例">#</a> 19.3.5. 一些应用实例</h4><p><img data-src="/images/JavaScript/%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6.png" alt="2"></p><p>表单：获取表单 input 里的文字长度时要加上.length；表单的一些属性：type value disabled</p><p>排他思想：给某个元素加属性前先把其他元素的属性全部消掉</p><p>换肤效果：注意换肤的元素改变图片地址的格式</p><p>介绍页面切换效果：要先给介绍标题加个自定义属性，以便后面通过点击某个介绍标题，切换到相应的介绍时，知道该是哪个详细介绍显示出来</p><p>创建的元素只能用一次，要用的话需要再次创建</p><p>动态生成表格案例：第一步，先把表格内每一行的数据创建成一个对象，再把这些对象放到数组里面；第二步根据数组内的对象个数创建行；第三步，在上一步的 for 循环里根据对象里的属性个数来创建单元格，获得对象里的属性用 for (var k in obj), 得到的 k 是属性名；第四步，获得对象里的数据并把它给单元格，用 obj [k] ，得到数据；第五步，创建删除单元格，在以上步骤后面进行，先生成单元格，并把 删除 赋给单元格；第六步，给删除加代码，使之能删除所在行，利用 node.removeChild (),node 为所删除元素的最近一级父元素，所以 node 为 tbody 然后因为我们是给删除加的代码，所以括号里为 this.parentNode.parentNode</p><h4 id="1936节点操作"><a class="anchor" href="#1936节点操作">#</a> 19.3.6. 节点操作</h4><p>一般地，节点至少拥有 nodeType (节点类型)，nodeName (节点名称)，nodeValue (节点值) 这三个属性</p><p>节点层级：一般是父兄子层级关系</p><p>获取一个元素的父级元素，使用 element.parentNode 得到的是离 element 最近的父级元素</p><p>获取一个元素的子节点，使用 element.childNodes 但返回的是所有的子节点，包括元素节点，文本节点等等，我们可以采用另一种方法来只获取元素的子元素节点 element.children, 在此基础上，还有 firstchild lastchild, 返回第一 (最后) 个子节点，不管是文本节点还是元素节点。firstElementChild lastElementChild, 返回的是第一 (最后) 个子元素节点，但是这两个有兼容性问题，所以我们一般用 children 返回的伪数组来选出想要的那个元素</p><p>获取一个元素的兄弟节点，使用 element.nextSibling previousSibling, 得到的包括文本节点 元素节点等等，还有 nextElementSibling previousElementSibling, 方法同上，但目前没有能直接获得兄弟元素节点的方法，所以我们需要自己封装一个函数，如下</p><p><img data-src="/images/JavaScript/%E5%85%84%E5%BC%9F%E5%85%83%E7%B4%A0%E8%8A%82%E7%82%B9.png" alt="2"></p><p>创建节点：document.createElement (''), 括号里接要生成的元素；添加节点：只创建节点是不够的，我们还需要把它添加到页面中某个具体的位置上去，这时用 node.appendChild ()，括号里接创建的元素，这个添加是添加到 node 的末尾，也可以用 node.insertBefore (child, 指定元素)，表示在指定元素的前面添加一个元素</p><p>删除节点：使用 node.removeChild () node 表示要删除元素的父元素，括号里写要删除的元素</p><p>复制节点：使用 node.clonenode () 括号里为 true 或 false 前者为深复制，既复制标签又复制内容，后者只复制标签，而且这个只是复制，我们还需要添加</p><p>三种创建元素方式区别</p><p><img data-src="/images/JavaScript/%E4%B8%89%E7%A7%8D%E5%88%9B%E5%BB%BA%E5%85%83%E7%B4%A0%E7%9A%84qubie.png" alt="2"></p><h4 id="1937事件高级"><a class="anchor" href="#1937事件高级">#</a> 19.3.7. 事件高级</h4><p>1. 传统注册方式：利用 on 开头的事件，如 onclick；2. 特点：注册事件的唯一性，同一个元素同一个事件只能设置一个处理函数，最后注册的注册的处理函数会覆盖前面注册的处理函数</p><p>事件监听方式：eventTarget.addEventListener (type,listenner [,useCapture]), 将指定的监听器注册到 eventTarget (目标对象) 上，当该对象触发指定的事件时，就会执行事件处理函数。type：事件类型字符串，要加引号，比如 click，mouseover，注意这里不要带 on；listener：事件处理函数，事件发生时，会调用该监听函数，若该函数为匿名函数，则后面需要加小括号调用，若为非匿名函数，则不需要添加小括号调用；useCapture：可选参数，是一个布尔值，默认是 false；同一个元素，同一个事件可以添加多个侦听器，按顺序执行</p><p>删除事件 (事件解绑)：1. 传统方式：element. 事件 = null；2. 利用 removeEventListener (' 事件 '，函数名)</p><h4 id="1938dom事件流"><a class="anchor" href="#1938dom事件流">#</a> 19.3.8.DOM 事件流</h4><p>事件流描述的是从页面中接收事件的顺序，事件发生时会在元素节点之间按照特定的顺序传播，这个传播过程即 DOM 事件流</p><p><img data-src="/images/JavaScript/dom%E4%BA%8B%E4%BB%B6%E6%B5%81.png" alt="2"></p><p>注意，JS 代码只能执行捕获或冒泡其中的一个阶段，以前用的 onclick 这类和 attachevent 只能得到冒泡阶段，addeventlistener (type,listener [,useCapture]) 第三个参数如果是 true，表示在事件捕获阶段调用事件处理程序；如果为 false (默认为 false)，表示在事件冒泡阶段调用事件处理程序。我们一般注重冒泡阶段。。</p><p>自己理解：处于捕获阶段，则代码从最大执行到最小，即先 document 再 html 再 body 再代码，如果某个子元素和父元素有事件，则先执行父元素的事件，然后再执行子元素的事件，即使未触发事件的触发条件；若为冒泡阶段，则相反</p><h4 id="1939事件对象"><a class="anchor" href="#1939事件对象">#</a> 19.3.9. 事件对象</h4><p>function () 后面的小括号里的东西就是事件对象，当形参来看。事件对象只有了事件才会存在，它是系统给我们自动创建的，不需要我们来传递参数</p><p>事件对象是我们事件的一系列相关数据的集合，跟事件相关的，比如鼠标点击事件里面就包含了鼠标的相关信息，如鼠标坐标之类的，如果是键盘事件里面就包含着键盘事件的相关信息，比如判断用户按下了哪个键；</p><p>事件对象的名字是我们自己命名的，可以看个人喜好，一般用 e</p><p>自己理解：事件对象就是一个系统创建的集合，可要可不要，当要用这个事件的一些相关东西时，便在 () 里加上一个 event，这个 event 就包含了这个事件发生时的一些相关信息 /p&gt;</p><h4 id="19310常见事件对象的属性和方法"><a class="anchor" href="#19310常见事件对象的属性和方法">#</a> 19.3.10. 常见事件对象的属性和方法</h4><p>target：获取方法 event.target，返回触发事件的对象 (元素)。和 this 的区别：this 返回绑定事件的对象，target 返回的是触发事件的对象 (元素)，如如果给 ul 绑定事件，然后点击 li，this 返回的是 ul，target 返回的是 li</p><p>type：返回事件的类型，如 click mouseover</p><p>preventDefault (): 阻止默认行为，如让链接不跳转，让提交按钮不提交</p><h4 id="19311阻止事件冒泡"><a class="anchor" href="#19311阻止事件冒泡">#</a> 19.3.11. 阻止事件冒泡</h4><p>一.stopPropagation ()，这是事件对象的一个属性，要想一个元素后的元素不再冒泡，就给这个元素的事件里加上一个 event.stopPropagation</p><h4 id="19312事件委托代理-委派"><a class="anchor" href="#19312事件委托代理-委派">#</a> 19.3.12. 事件委托 (代理 委派)</h4><p>不是给每个子节点单独设置事件监视器，而是事件监视器设置在其父节点上，然后利用冒泡原理影响设置每个字节点</p><p>自己理解：当我们要给每个子元素添加事件，但子元素又比较多时，我们可以给该子元素的父元素添加事件，这样，当我们对任意一个子元素进行处理时，该处理就会冒泡到父元素上，父元素的事件就会被执行，如果我们要对点击的那个子元素处理的话，我们可以在父元素的事件的 function 的括号里带上一个参数 e，e.target 便可得到该子元素</p><h4 id="19313不常见的鼠标事件"><a class="anchor" href="#19313不常见的鼠标事件">#</a> 19.3.13. 不常见的鼠标事件</h4><p>禁止鼠标右键菜单：contextmenu 主要控制应该何时显示上下文菜单，主要用于程序员取消默认的上下文菜单，和 click 等用法一样。要禁止右键菜单，可以给事件对象 e 加上 e.preventDefault (); 表示禁止打开菜单的默认行为。</p><p>但是以上方法还有缺陷，仍可以通过键盘事件进行复制等操作</p><p>禁止鼠标选中：selectstart, 表示开始选中，跟上述方法一样，可以加上 e.preventDefault (), 这样就无法选中了</p><h4 id="19314鼠标事件对象"><a class="anchor" href="#19314鼠标事件对象">#</a> 19.3.14. 鼠标事件对象</h4><p><img data-src="/images/JavaScript/%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1.png" alt="2"></p><p>client 表示可视区域，如果打开了控制台，则控制台的部分不算入可视区域，如果页面可以翻滚，client 表示的坐标也不会改变，它只表示点击位置在当前可视区域的坐标位置</p><p>page 表示文档页面，此时的 y 坐标表示点击位置距离该页面文档的顶部的距离，会随着页面翻滚而改变</p><p>一个小技巧：跟随鼠标移动的天使，步骤：给 document 添加一个 mousemove 事件，然后获取鼠标的 page 坐标，并赋给图片的坐标，别忘了加上一个 'px'</p><h4 id="19315键盘事件"><a class="anchor" href="#19315键盘事件">#</a> 19.3.15. 键盘事件</h4><p><img data-src="/images/JavaScript/%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6.png" alt="2"></p><p>三个事件执行有顺序，down press up</p><p>键盘事件对象：通过 keyCode 判断按下的哪个键，每一个按键对应一个 ASCLL 码值</p><p>up 和 down 不区分大小写，即大小写均得到同一个 ASCLL 码值，但 press 区分大小写</p><h4 id="194bom"><a class="anchor" href="#194bom">#</a> 19.4.BOM</h4><p>BOM 是浏览器对象模型，它提供了独立于内容而与浏览器窗口进行交互的对象</p><p>window 对象是浏览器的顶级对象，它具有双重角色，它是 js 访问浏览器窗口的一个接口；它也是一个全局对象，定义在全局作用域中的变量、函数都会变成 windows 对象的属性和方法，BOM 比 DOM 大</p><h4 id="1941窗口加载事件"><a class="anchor" href="#1941窗口加载事件">#</a> 19.4.1. 窗口加载事件</h4><p>onload 或 load 是窗口加载事件，当文档内容完全加载完成会触发该事件 (包括图像，脚本文件，CSS 文件等)</p><p>注意：1. 有了 window》onload 就可以把 js 代码写到页面元素的上方，因为 onload 是等页面内容全部加载完毕，再去执行处理函数。2.window.onload 传统注册事件方式只能写一次，如果有多个，会以最后一个 window.onload 为准，但用 addEventListener ('load',function ()) 就可以写多个</p><p>DOMContentLoaded 事件触发时，仅当 DOM 加载完成，不包括样式表，图片，flash 等等，如果页面图片比较多时，加载时间很长，此时就可以用 DOMContentLoaded</p><h4 id="1942调整窗口大小事件"><a class="anchor" href="#1942调整窗口大小事件">#</a> 19.4.2. 调整窗口大小事件</h4><p>resize 或者 onresize 是调整窗口大小加载事件，当触发时就调用的处理函数。只要窗口大小像素发生变化，就会触发这个事件，window.innerWidth 来获取当前屏幕的宽度</p><h4 id="1943定时器"><a class="anchor" href="#1943定时器">#</a> 19.4.3. 定时器</h4><p>setTimeout (调用函数，[延迟的毫秒数])，该方法用于设置一个定时器，该定时器到期后执行调用函数。但实际应用中，一个页面往往有多个定时器，所以我们可以给定时器赋值一个标识符 (名字)，就相当于把定时器当变量来处理，如 var time1=setTimeout ()；</p><p>定时器也叫回调函数 callback，因为定时器执行操作需要等待时间，等时间到了才执行，因此称为回调函数</p><p>停止定时器，用 clearTimeout ()，括号里写定时器的名字</p><p>setInterval () 也是定时器，使用方法跟上面一样，但这个函数是反复调用一个函数，每隔所设定的时间，就执行一次函数</p><p>clearInterval (), 括号里接定时器的名字</p><h4 id="1944this的指向问题"><a class="anchor" href="#1944this的指向问题">#</a> 19.4.4.this 的指向问题</h4><p>一般情况下，this 的最终指向的是那个调用它的对象</p><p>1. 全局作用域或者普通函数中 this 指向全局对象 window (定时器里面的 this 指向 window)</p><p>2. 方法调用中谁调用 this 指向谁。一个对象里有多个属性，有些属性是一个函数，此时，谁调用了 this，this 就指向谁</p><p>3. 构造函数中 this 指向构造函数的实例。构造函数要用 new，new 就给该构造函数开辟了一个空间，此时的 this 就指向这个空间，如果将这个构造函数赋给了其他变量，那么 this 就指向这个变量</p><h4 id="1945js的执行队列"><a class="anchor" href="#1945js的执行队列">#</a> 19.4.5.JS 的执行队列</h4><p>js 语言的最大一特点就是单线程，也就是说，同一个时间只能做一件事。</p><h4 id="1946js的执行机制"><a class="anchor" href="#1946js的执行机制">#</a> 19.4.6.js 的执行机制</h4><p>同步就是指同一时间只能处理一个任务，任务按顺序执行。异步就是同一时间可以处理多个任务</p><p>js 先执行执行栈中的同步任务，然后将异步任务 (回调函数) 放入任务队列中，最后一旦执行栈中的所有同步任务执行完毕，系统就会按次序读取任务队列中的异步任务，于是被读取的异步任务结束等待状态，进入执行栈，开始执行</p><p><img data-src="/images/JavaScript/js%E7%9A%84%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6.png" alt="2"></p><h4 id="1946location对象"><a class="anchor" href="#1946location对象">#</a> 19.4.6.location 对象</h4><p>url 的格式</p><p><img data-src="/images/JavaScript/url%E7%9A%84%E6%A0%BC%E5%BC%8F.png" alt="2"></p><p>location 对象的属性</p><p><img data-src="/images/JavaScript/location%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7.png" alt="2"></p><p>重点记住 href 和 search</p><p>页面跳转案例：该案例要求的是把一个页面里的数据传到另一个页面去使用，这要使用表单里的 form，action 里填数据传输到的页面，然后再来一个类型为 submit 的 input 就可以将数据传输到 action 里的页面，然后就是获取数据，利用 location.search, 就可以获取到数据，但是获取到的数据里面有？和 &amp; 等我们并不需要的字符，这时，我们就可以利用 substr (起始的位置，截取几个字符)(注意，这个函数是从 0 开始计数的) 来截取字符，也可以用 split (' 符号 ') 来去掉字符串中的某个字符，并将剩下的部分以数组方式存储</p><p>location 对象的方法：<img data-src="/images/JavaScript/location%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95.png" alt="2"></p><p>其中第一个能记录浏览历史，可以实现后退功能</p><p>navigator，可以用来识别是移动端打开的网站还是 pc 端打开的网站，以此来展示不同的页面</p><h2 id="20pc端网页特效"><a class="anchor" href="#20pc端网页特效">#</a> 20.PC 端网页特效</h2><h3 id="201offset系列属性"><a class="anchor" href="#201offset系列属性">#</a> 20.1.offset 系列属性</h3><p>offset 翻译过来就是偏移量，我们使用 offset 系列相关属性可以动态的得到该元素的位置 (偏移)，大小。它的作用有：获得元素距离带有定位父元素的位置；获得元素自身的大小；注意，返回的数值都不带单位</p><p><img data-src="/images/JavaScript/offset%E7%B3%BB%E5%88%97%E5%B1%9E%E6%80%A7.png" alt="2"></p><p>注意，如果没有父元素或者父元素没有定位，则返回距离 body 的距离</p><h4 id="2011offset与style区别"><a class="anchor" href="#2011offset与style区别">#</a> 20.1.1.offset 与 style 区别</h4><p><img data-src="/images/JavaScript/offset%E4%B8%8Estyle%E7%9A%84%E5%8C%BA%E5%88%AB.png" alt="2"></p><h4 id="2012实际案例"><a class="anchor" href="#2012实际案例">#</a> 20.1.2. 实际案例</h4><p>获取坐标案例：利用 offset 里的 offsettop 和 offsetleft, 再加上事件对象里的 pagex 和 pagey 可以得到鼠标在盒子里的坐标</p><p>拖拽盒子案例：首先要弄懂事情是怎样完成的，鼠标按下，然后盒子跟随鼠标移动，最后鼠标弹起，盒子固定。所以我们首先要给盒子注册一个 mousedown 事件。然后在该事件里注册一个 mousemove 案例，最后在该事件里注册一个 mouseup 事件，在 mousedown 事件里我们要注意，鼠标在盒子里的坐标没变，变的是盒子的 offsetleft，所以我们首先要获得鼠标在盒子里的坐标 (这个坐标是固定的，不会改变)，方法同上，然后在 mousemove 事件里用 e.pagex 和 e.pagey 减去鼠标在盒子里的坐标就得到了 offset 的属性，然后就可以实现鼠标拖拽盒子，最后在 mouseup 事件里就可以把 mousemove 事件移除</p><h3 id="202client系列属性"><a class="anchor" href="#202client系列属性">#</a> 20.2.client 系列属性</h3><p><img data-src="/images/JavaScript/client.png" alt="2"></p><h3 id="203scroll系列属性"><a class="anchor" href="#203scroll系列属性">#</a> 20.3.scroll 系列属性</h3><p><img data-src="/images/JavaScript/scroll%E5%B1%9E%E6%80%A7.png" alt="2"></p><p>它的后面两个是包含 padding 的，且得到的是内容的属性，如果内容超出了盒子，其大小也会改变</p><h3 id="204三大系列总结"><a class="anchor" href="#204三大系列总结">#</a> 20.4. 三大系列总结</h3><p>offset 系列经常用于获得元素位置 offsetLeft,offsetTop. client 经常用于获取元素大小 clientWidth,clientHeight. scroll 经常用于获取滚动距离 scrollTop，scrollLeft, 注意页面的滚动距离通过 window.pageXoffset 获得</p><h3 id="205mouseover和mouseenter的区别"><a class="anchor" href="#205mouseover和mouseenter的区别">#</a> 20.5.mouseover 和 mouseenter 的区别</h3><p>当鼠标移到元素上时就会触发 mouseenter 事件，类似于 mouseover，它们两者的区别是，mouseover 鼠标经过自身盒子就会触发，经过子盒子还会触发，mouseenter 只会经过自身盒子触发，之所以这样，就是因为 mouseenter 不会冒泡</p><h3 id="206动画原理"><a class="anchor" href="#206动画原理">#</a> 20.6. 动画原理</h3><p>页面动画过多，我们可以声明一个动画函数，将要添加的元素的名字和停止条件作为参数传进去</p><p><img data-src="/images/JavaScript/%E7%AE%80%E5%8D%95%E5%8A%A8%E7%94%BB%E5%87%BD%E6%95%B0.png" alt="2"></p><p>但这个函数有个 bug，有的时候我们需要点击才能触发动画，所以我们有时需要添加一个点击事件来触发这个函数，但当我们不断点击时，这个函数就会不停调用，元素的定时器也不断叠加，导致出现我们不想要的效果，解决方法就是在函数内部的最前面加上一句 clearInterval (obj.timer)，就可以在添加定时器前把元素本来的定时器取消掉</p><h3 id="207缓动画"><a class="anchor" href="#207缓动画">#</a> 20.7. 缓动画</h3><p>缓动画，就是让动画的速度不是保持恒速，就是让元素移动的距离不保持恒定，核心算法就是 (目标值 - 现在的位置)/10 作为移动的步长，这样的话每次移动的步长就会随着离目标位置的接近而减小，但此时因为除 10 会出现小数，导致最终抵达不了目标位置，此时，我们需要把步长取整，且是向上取整。如果要在多个目标值之间移动，则需要判断步长是正数还是负数，正数的话就向上取整，负数的话就向下取整</p><h3 id="208缓动动画添加回调函数"><a class="anchor" href="#208缓动动画添加回调函数">#</a> 20.8. 缓动动画添加回调函数</h3><p>就是在缓动动画结束时执行一个函数，需要向函数里再多传递一个参数，我们一般将这个参数定为 callback，然后在缓动动画结束时加一个判断，如果 callback 存在，则执行</p><p>我们在实际使用中肯定不可能每一次都将 animate 函数写出来，所以我们可以将这个函数单独写入一个 js 文件里，后面要使用的时候直接引用就行了</p></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2022-05-12 20:44:00" itemprop="dateModified" datetime="2022-05-12T20:44:00+08:00">2022-05-12</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="Greg yang 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="Greg yang 支付宝"><p>支付宝</p></div><div><img data-src="/images/paypal.png" alt="Greg yang 贝宝"><p>贝宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>Greg yang <i class="ic i-at"><em>@</em></i></li><li class="link"><strong>本文链接：</strong> <a href="https://github.com/Greg267/javascipt/" title="JavaScript">https://github.com/Greg267/javascipt/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva2.sinaimg.cn&#x2F;mw690&#x2F;008qflI6ly8h25g83b2kjj308c05kglo.jpg" title="数据结构"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i></span><h3>数据结构</h3></a></div><div class="item right"><a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20copy/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva2.sinaimg.cn&#x2F;mw690&#x2F;008qflI6ly8h25fuse10xj31900u0go8.jpg" title="数据结构"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i></span><h3>数据结构</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1js%E7%9A%84%E5%BC%95%E5%85%A5"><span class="toc-number">1.</span> <span class="toc-text">&lt;1&gt;.js 的引入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2js%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E8%AF%AD%E5%8F%A5"><span class="toc-number">2.</span> <span class="toc-text">&lt;2&gt;js 的输入输出语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%8F%98%E9%87%8F"><span class="toc-number">3.</span> <span class="toc-text">&lt;3&gt; 变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E6%95%B0%E5%AD%97%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.</span> <span class="toc-text">&lt;4&gt;. 数字类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#a%E6%95%B0%E5%AD%97%E5%9E%8Bnumber"><span class="toc-number">4.1.</span> <span class="toc-text">a. 数字型 (number)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#b%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%9E%8Bstring"><span class="toc-number">4.2.</span> <span class="toc-text">b. 字符串型 string</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#c%E5%B8%83%E5%B0%94%E5%9E%8B"><span class="toc-number">4.3.</span> <span class="toc-text">c. 布尔型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dundefined%E5%92%8Cnull"><span class="toc-number">4.4.</span> <span class="toc-text">d.undefined 和 null</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E8%8E%B7%E5%8F%96%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.</span> <span class="toc-text">&lt;5&gt;. 获取变量类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">6.</span> <span class="toc-text">&lt;6&gt;. 数据类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#a%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">6.1.</span> <span class="toc-text">a. 转换为字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#b%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%95%B0%E5%AD%97%E5%9E%8B"><span class="toc-number">6.2.</span> <span class="toc-text">b. 转换为数字型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#c%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%B8%83%E5%B0%94%E5%9E%8B"><span class="toc-number">6.3.</span> <span class="toc-text">c. 转换为布尔型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E7%AE%97%E6%95%B0%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">7.</span> <span class="toc-text">&lt;7&gt;. 算数运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#a%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">7.1.</span> <span class="toc-text">a. 运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#b%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">7.2.</span> <span class="toc-text">b. 表达式和返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#c%E9%80%92%E5%A2%9E%E5%92%8C%E9%80%92%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">7.3.</span> <span class="toc-text">c. 递增和递减运算符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">8.</span> <span class="toc-text">&lt;8&gt;. 比较运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">9.</span> <span class="toc-text">&lt;9&gt;. 逻辑运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#a%E7%9F%AD%E8%B7%AF%E8%BF%90%E7%AE%97"><span class="toc-number">9.1.</span> <span class="toc-text">a. 短路运算</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">10.</span> <span class="toc-text">&lt;10&gt;. 赋值运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">10.0.1.</span> <span class="toc-text">运算符优先级</span></a></li></ol></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#11%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">11.</span> <span class="toc-text">&lt;11&gt;. 流程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#a%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84"><span class="toc-number">11.1.</span> <span class="toc-text">a. 分支结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1if%E8%AF%AD%E5%8F%A5"><span class="toc-number">11.1.1.</span> <span class="toc-text">1.if 语句</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E5%88%86%E6%94%AF%E8%AF%AD%E5%8F%A5"><span class="toc-number">11.1.1.1.</span> <span class="toc-text">多分支语句</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E4%B8%89%E5%85%83%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">11.1.2.</span> <span class="toc-text">2. 三元表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3switch%E8%AF%AD%E5%8F%A5"><span class="toc-number">11.1.3.</span> <span class="toc-text">3.switch 语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3if-else-if%E5%92%8Cswitch%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">11.1.4.</span> <span class="toc-text">3.if else if 和 switch 的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#b%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84"><span class="toc-number">11.2.</span> <span class="toc-text">b. 循环结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1for"><span class="toc-number">11.2.1.</span> <span class="toc-text">1.for</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#for-%E5%BE%AA%E7%8E%AF%E6%89%A7%E8%A1%8C%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="toc-number">11.2.1.1.</span> <span class="toc-text">for 循环执行不同的代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#for-%E5%9C%A8%E4%B8%80%E8%A1%8C%E4%B8%AD%E8%BF%9E%E7%BB%AD%E6%89%93%E5%8D%B0%E5%AD%97%E7%AC%A6"><span class="toc-number">11.2.1.2.</span> <span class="toc-text">for 在一行中连续打印字符</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E5%8F%8C%E9%87%8Dfor%E5%BE%AA%E7%8E%AF"><span class="toc-number">11.2.2.</span> <span class="toc-text">2. 双重 for 循环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3while%E8%AF%AD%E5%8F%A5"><span class="toc-number">11.2.3.</span> <span class="toc-text">3.while 语句</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4do"><span class="toc-number">11.2.3.1.</span> <span class="toc-text">4.do while 循环</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E5%B0%8F%E7%BB%93"><span class="toc-number">11.3.</span> <span class="toc-text">循环小结</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5continue%E5%92%8Cbreak"><span class="toc-number">11.3.0.1.</span> <span class="toc-text">5.continue 和 break</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12%E6%95%B0%E7%BB%84"><span class="toc-number">12.</span> <span class="toc-text">&lt;12&gt;. 数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E6%95%B0%E7%BB%84%E7%9A%84%E7%B4%A2%E5%BC%95"><span class="toc-number">12.1.</span> <span class="toc-text">1. 数组的索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E9%81%8D%E5%8E%86%E6%95%B0%E7%BB%84"><span class="toc-number">12.2.</span> <span class="toc-text">2. 遍历数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E9%95%BF%E5%BA%A6"><span class="toc-number">12.3.</span> <span class="toc-text">数组长度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E6%95%B0%E7%BB%84%E6%96%B0%E5%A2%9E%E5%85%83%E7%B4%A0"><span class="toc-number">12.4.</span> <span class="toc-text">3. 数组新增元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E6%95%B0%E7%BB%84%E6%8E%92%E5%88%97"><span class="toc-number">12.5.</span> <span class="toc-text">4. 数组排列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13%E5%87%BD%E6%95%B0"><span class="toc-number">13.</span> <span class="toc-text">&lt;13&gt;. 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E5%87%BD%E6%95%B0%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="toc-number">13.1.</span> <span class="toc-text">1. 函数的声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8"><span class="toc-number">13.2.</span> <span class="toc-text">2. 函数的调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E5%87%BD%E6%95%B0%E7%9A%84%E5%B0%81%E8%A3%85"><span class="toc-number">13.3.</span> <span class="toc-text">3. 函数的封装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0"><span class="toc-number">13.4.</span> <span class="toc-text">4. 函数的参数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%BD%A2%E5%8F%82%E5%92%8C%E5%AE%9E%E5%8F%82%E4%B8%AA%E6%95%B0%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98"><span class="toc-number">13.4.1.</span> <span class="toc-text">函数形参和实参个数匹配问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">13.5.</span> <span class="toc-text">5. 函数的返回值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#breakcontinuereturn%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">13.5.1.</span> <span class="toc-text">break，continue，return 的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6arguments%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">13.6.</span> <span class="toc-text">6.arguments 的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%A3%B0%E6%98%8E%E6%96%B9%E5%BC%8F"><span class="toc-number">13.7.</span> <span class="toc-text">7. 函数的两种声明方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14javascript%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">14.</span> <span class="toc-text">&lt;14&gt;.JavaScript 作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">14.1.</span> <span class="toc-text">1. 作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%85%A8%E5%B1%80%E4%BD%9C%E7%94%A8%E5%9F%9F-%E5%B1%80%E9%83%A8%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">14.2.</span> <span class="toc-text">两种作用域：全局作用域、局部作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">14.3.</span> <span class="toc-text">2. 变量作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E6%95%88%E7%8E%87"><span class="toc-number">14.3.1.</span> <span class="toc-text">作用效率</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#js%E6%B2%A1%E6%9C%89%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9Fes6%E7%9A%84%E6%97%B6%E5%80%99%E6%89%8D%E6%9C%89"><span class="toc-number">14.3.2.</span> <span class="toc-text">js 没有块级作用域 es6 的时候才有</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE"><span class="toc-number">14.4.</span> <span class="toc-text">3. 作用域链</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15javascript%E9%A2%84%E8%A7%A3%E6%9E%90"><span class="toc-number">15.</span> <span class="toc-text">&lt;15&gt;.JavaScript 预解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1js%E5%BC%95%E6%93%8E%E8%BF%90%E8%A1%8Cjs%E5%88%86%E4%B8%BA%E4%B8%A4%E6%AD%A5%E9%A2%84%E8%A7%A3%E6%9E%90-%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C"><span class="toc-number">15.1.</span> <span class="toc-text">1.js 引擎运行 js 分为两步：预解析 代码执行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E9%A2%84%E8%A7%A3%E6%9E%90%E5%88%86%E4%B8%BA%E5%8F%98%E9%87%8F%E9%A2%84%E8%A7%A3%E6%9E%90%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E5%92%8C%E5%87%BD%E6%95%B0%E9%A2%84%E8%A7%A3%E6%9E%90%E5%87%BD%E6%95%B0%E6%8F%90%E5%8D%87"><span class="toc-number">15.2.</span> <span class="toc-text">2. 预解析分为变量预解析 (变量提升) 和函数预解析 (函数提升)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16javascript%E5%AF%B9%E8%B1%A1"><span class="toc-number">16.</span> <span class="toc-text">&lt;16&gt;.JavaScript 对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E5%AF%B9%E8%B1%A1"><span class="toc-number">16.1.</span> <span class="toc-text">1. 对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="toc-number">16.2.</span> <span class="toc-text">2. 创建对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E9%9D%A2%E9%87%8F%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="toc-number">16.2.1.</span> <span class="toc-text">字面量创建对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AF%B9%E8%B1%A1"><span class="toc-number">16.2.2.</span> <span class="toc-text">使用对象</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-number">16.2.2.1.</span> <span class="toc-text">调用对象的属性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">16.2.2.2.</span> <span class="toc-text">调用对象的方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E5%8F%98%E9%87%8F-%E5%B1%9E%E6%80%A7-%E5%87%BD%E6%95%B0-%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">16.3.</span> <span class="toc-text">3. 变量、属性、函数、方法的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A9%E7%94%A8new-object%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="toc-number">16.3.1.</span> <span class="toc-text">利用 new Object 创建对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="toc-number">16.3.2.</span> <span class="toc-text">利用构造函数创建对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#new%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">16.3.3.</span> <span class="toc-text">new 关键字的执行过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E5%AF%B9%E8%B1%A1"><span class="toc-number">16.3.4.</span> <span class="toc-text">遍历对象</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17javascript%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1"><span class="toc-number">17.</span> <span class="toc-text">&lt;17&gt;.JavaScript 内置对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1math%E5%AF%B9%E8%B1%A1"><span class="toc-number">17.1.</span> <span class="toc-text">1.Math 对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2date%E5%AF%B9%E8%B1%A1"><span class="toc-number">17.2.</span> <span class="toc-text">2.Date 对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%AF%AB%E7%A7%92%E6%95%B0"><span class="toc-number">17.2.1.</span> <span class="toc-text">获取毫秒数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%80%92%E8%AE%A1%E6%97%B6"><span class="toc-number">17.2.2.</span> <span class="toc-text">倒计时</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1"><span class="toc-number">17.3.</span> <span class="toc-text">3. 数组对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A3%80%E6%B5%8B%E6%98%AF%E5%90%A6%E4%B8%BA%E6%95%B0%E7%BB%84"><span class="toc-number">17.3.1.</span> <span class="toc-text">检测是否为数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E6%88%96%E5%88%A0%E9%99%A4%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0"><span class="toc-number">17.3.2.</span> <span class="toc-text">添加或删除数组元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E9%A2%A0%E5%80%92%E6%95%B0%E7%BB%84"><span class="toc-number">17.3.3.</span> <span class="toc-text">4. 颠倒数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E6%95%B0%E7%BB%84%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-number">17.3.4.</span> <span class="toc-text">5. 数组冒泡排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E8%8E%B7%E5%8F%96%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%B4%A2%E5%BC%95"><span class="toc-number">17.3.5.</span> <span class="toc-text">6. 获取数组元素索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E6%A1%88%E4%BE%8B"><span class="toc-number">17.3.6.</span> <span class="toc-text">数组去重案例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">17.3.7.</span> <span class="toc-text">7. 数组转换为字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8%E5%9F%BA%E6%9C%AC%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B"><span class="toc-number">17.3.8.</span> <span class="toc-text">8. 基本包装类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98"><span class="toc-number">17.3.9.</span> <span class="toc-text">9. 字符串的不可变</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10%E6%A0%B9%E6%8D%AE%E5%AD%97%E7%AC%A6%E8%BF%94%E5%9B%9E%E4%BD%8D%E7%BD%AE"><span class="toc-number">17.3.10.</span> <span class="toc-text">10. 根据字符返回位置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10%E6%A0%B9%E6%8D%AE%E4%BD%8D%E7%BD%AE%E8%BF%94%E5%9B%9E%E5%AD%97%E7%AC%A6"><span class="toc-number">17.3.11.</span> <span class="toc-text">10. 根据位置返回字符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E7%BB%9F%E8%AE%A1%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AD%97%E7%AC%A6"><span class="toc-number">17.4.</span> <span class="toc-text">案例：统计出现次数最多的字符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95"><span class="toc-number">17.4.1.</span> <span class="toc-text">11. 字符串操作方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18javascrip%E7%AE%80%E5%8D%95%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%A4%8D%E6%9D%82%E7%B1%BB%E5%9E%8B"><span class="toc-number">18.</span> <span class="toc-text">18.JavaScrip 简单类型与复杂类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19web"><span class="toc-number">19.</span> <span class="toc-text">19.Web APIs</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#191web"><span class="toc-number">19.1.</span> <span class="toc-text">19.1.Web APIs 和 JS 基础关联性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#192api%E5%92%8Cwebapi"><span class="toc-number">19.2.</span> <span class="toc-text">19.2.API 和 WebAPI</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#193dom"><span class="toc-number">19.3.</span> <span class="toc-text">19.3.DOM</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1931%E8%8E%B7%E5%8F%96%E9%A1%B5%E9%9D%A2%E5%85%83%E7%B4%A0"><span class="toc-number">19.3.1.</span> <span class="toc-text">19.3.1. 获取页面元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1932%E4%BA%8B%E4%BB%B6%E5%9F%BA%E7%A1%80"><span class="toc-number">19.3.2.</span> <span class="toc-text">19.3.2. 事件基础</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1933%E6%93%8D%E4%BD%9C%E5%85%83%E7%B4%A0"><span class="toc-number">19.3.3.</span> <span class="toc-text">19.3.3. 操作元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1934%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7"><span class="toc-number">19.3.4.</span> <span class="toc-text">19.3.4. 自定义属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1935%E4%B8%80%E4%BA%9B%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B"><span class="toc-number">19.3.5.</span> <span class="toc-text">19.3.5. 一些应用实例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1936%E8%8A%82%E7%82%B9%E6%93%8D%E4%BD%9C"><span class="toc-number">19.3.6.</span> <span class="toc-text">19.3.6. 节点操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1937%E4%BA%8B%E4%BB%B6%E9%AB%98%E7%BA%A7"><span class="toc-number">19.3.7.</span> <span class="toc-text">19.3.7. 事件高级</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1938dom%E4%BA%8B%E4%BB%B6%E6%B5%81"><span class="toc-number">19.3.8.</span> <span class="toc-text">19.3.8.DOM 事件流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1939%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1"><span class="toc-number">19.3.9.</span> <span class="toc-text">19.3.9. 事件对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#19310%E5%B8%B8%E8%A7%81%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95"><span class="toc-number">19.3.10.</span> <span class="toc-text">19.3.10. 常见事件对象的属性和方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#19311%E9%98%BB%E6%AD%A2%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1"><span class="toc-number">19.3.11.</span> <span class="toc-text">19.3.11. 阻止事件冒泡</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#19312%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%E4%BB%A3%E7%90%86-%E5%A7%94%E6%B4%BE"><span class="toc-number">19.3.12.</span> <span class="toc-text">19.3.12. 事件委托 (代理 委派)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#19313%E4%B8%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6"><span class="toc-number">19.3.13.</span> <span class="toc-text">19.3.13. 不常见的鼠标事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#19314%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1"><span class="toc-number">19.3.14.</span> <span class="toc-text">19.3.14. 鼠标事件对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#19315%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6"><span class="toc-number">19.3.15.</span> <span class="toc-text">19.3.15. 键盘事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#194bom"><span class="toc-number">19.3.16.</span> <span class="toc-text">19.4.BOM</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1941%E7%AA%97%E5%8F%A3%E5%8A%A0%E8%BD%BD%E4%BA%8B%E4%BB%B6"><span class="toc-number">19.3.17.</span> <span class="toc-text">19.4.1. 窗口加载事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1942%E8%B0%83%E6%95%B4%E7%AA%97%E5%8F%A3%E5%A4%A7%E5%B0%8F%E4%BA%8B%E4%BB%B6"><span class="toc-number">19.3.18.</span> <span class="toc-text">19.4.2. 调整窗口大小事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1943%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-number">19.3.19.</span> <span class="toc-text">19.4.3. 定时器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1944this%E7%9A%84%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98"><span class="toc-number">19.3.20.</span> <span class="toc-text">19.4.4.this 的指向问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1945js%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%9F%E5%88%97"><span class="toc-number">19.3.21.</span> <span class="toc-text">19.4.5.JS 的执行队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1946js%E7%9A%84%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6"><span class="toc-number">19.3.22.</span> <span class="toc-text">19.4.6.js 的执行机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1946location%E5%AF%B9%E8%B1%A1"><span class="toc-number">19.3.23.</span> <span class="toc-text">19.4.6.location 对象</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20pc%E7%AB%AF%E7%BD%91%E9%A1%B5%E7%89%B9%E6%95%88"><span class="toc-number">20.</span> <span class="toc-text">20.PC 端网页特效</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#201offset%E7%B3%BB%E5%88%97%E5%B1%9E%E6%80%A7"><span class="toc-number">20.1.</span> <span class="toc-text">20.1.offset 系列属性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2011offset%E4%B8%8Estyle%E5%8C%BA%E5%88%AB"><span class="toc-number">20.1.1.</span> <span class="toc-text">20.1.1.offset 与 style 区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2012%E5%AE%9E%E9%99%85%E6%A1%88%E4%BE%8B"><span class="toc-number">20.1.2.</span> <span class="toc-text">20.1.2. 实际案例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#202client%E7%B3%BB%E5%88%97%E5%B1%9E%E6%80%A7"><span class="toc-number">20.2.</span> <span class="toc-text">20.2.client 系列属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#203scroll%E7%B3%BB%E5%88%97%E5%B1%9E%E6%80%A7"><span class="toc-number">20.3.</span> <span class="toc-text">20.3.scroll 系列属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#204%E4%B8%89%E5%A4%A7%E7%B3%BB%E5%88%97%E6%80%BB%E7%BB%93"><span class="toc-number">20.4.</span> <span class="toc-text">20.4. 三大系列总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#205mouseover%E5%92%8Cmouseenter%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">20.5.</span> <span class="toc-text">20.5.mouseover 和 mouseenter 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#206%E5%8A%A8%E7%94%BB%E5%8E%9F%E7%90%86"><span class="toc-number">20.6.</span> <span class="toc-text">20.6. 动画原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#207%E7%BC%93%E5%8A%A8%E7%94%BB"><span class="toc-number">20.7.</span> <span class="toc-text">20.7. 缓动画</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#208%E7%BC%93%E5%8A%A8%E5%8A%A8%E7%94%BB%E6%B7%BB%E5%8A%A0%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="toc-number">20.8.</span> <span class="toc-text">20.8. 缓动动画添加回调函数</span></a></li></ol></li></div><div class="related panel pjax" data-title="系列文章"></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Greg yang" data-src="/images/avatar.jpg"><p class="name" itemprop="name">Greg yang</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">6</span> <span class="name">文章</span></a></div></nav><div class="social"><a href="https://github.com/Greg267" title="https:&#x2F;&#x2F;github.com&#x2F;Greg267" class="item github"><i class="ic i-github"></i></a> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9tci15LTIwLTIxLTYx" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;mr-y-20-21-61"><i class="ic i-zhihu"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTYwNjE4NTYxMQ==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;606185611"><i class="ic i-cloud-music"></i></span> <span class="exturl item weibo" data-url="aHR0cHM6Ly93ZWliby5jb20vNzcxNjkwNTc3MC9wcm9maWxlP3RvcG5hdj0xJnd2cj02" title="https:&#x2F;&#x2F;weibo.com&#x2F;7716905770&#x2F;profile?topnav&#x3D;1&amp;wvr&#x3D;6"><i class="ic i-weibo"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>friends</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20copy/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"></div><span><a href="/hello-world/" title="Hello World">Hello World</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/Ajax/" title="Ajax">Ajax</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="数据结构">数据结构</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20copy/" title="数据结构">数据结构</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/C%E8%AF%AD%E8%A8%80/" title="C语言">C语言</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/javascipt/" title="JavaScript">JavaScript</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Greg yang @ Greg yang</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">74k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">1:07</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<a href="https://github.com/amehime/hexo-theme-shoka">Shoka</a></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"javascipt/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html>